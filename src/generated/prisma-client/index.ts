// Code generated by Prisma (prisma@1.23.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,

} from "prisma-client-lib";
import { typeDefs} from "./prisma-schema";
import { Model } from 'prisma-client-lib/dist/types';

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  address: (where?: AddressWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  coordinate: (where?: CoordinateWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  permission: (where?: PermissionWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  role: (where?: RoleWhereInput) => Promise<boolean>;
  settings: (where?: SettingsWhereInput) => Promise<boolean>;
  telephoneNumber: (where?: TelephoneNumberWhereInput) => Promise<boolean>;
  tenant: (where?: TenantWhereInput) => Promise<boolean>;
  tenantUserRole: (where?: TenantUserRoleWhereInput) => Promise<boolean>;
  timeZone: (where?: TimeZoneWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  address: (where: AddressWhereUniqueInput) => AddressPromise;
  addresses: (
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Address>;
  addressesConnection: (
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AddressConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentPromise;
  comments: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Comment>;
  commentsConnection: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommentConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyPromise;
  companies: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Company>;
  companiesConnection: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CompanyConnectionPromise;
  coordinate: (where: CoordinateWhereUniqueInput) => CoordinatePromise;
  coordinates: (
    args?: {
      where?: CoordinateWhereInput;
      orderBy?: CoordinateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Coordinate>;
  coordinatesConnection: (
    args?: {
      where?: CoordinateWhereInput;
      orderBy?: CoordinateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CoordinateConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImagePromise;
  images: (
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Image>;
  imagesConnection: (
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ImageConnectionPromise;
  permission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  permissions: (
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Permission>;
  permissionsConnection: (
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PermissionConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostPromise;
  posts: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Post>;
  postsConnection: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  role: (where: RoleWhereUniqueInput) => RolePromise;
  roles: (
    args?: {
      where?: RoleWhereInput;
      orderBy?: RoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Role>;
  rolesConnection: (
    args?: {
      where?: RoleWhereInput;
      orderBy?: RoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => RoleConnectionPromise;
  settings: (where: SettingsWhereUniqueInput) => SettingsPromise;
  settingses: (
    args?: {
      where?: SettingsWhereInput;
      orderBy?: SettingsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Settings>;
  settingsesConnection: (
    args?: {
      where?: SettingsWhereInput;
      orderBy?: SettingsOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SettingsConnectionPromise;
  telephoneNumber: (
    where: TelephoneNumberWhereUniqueInput
  ) => TelephoneNumberPromise;
  telephoneNumbers: (
    args?: {
      where?: TelephoneNumberWhereInput;
      orderBy?: TelephoneNumberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TelephoneNumber>;
  telephoneNumbersConnection: (
    args?: {
      where?: TelephoneNumberWhereInput;
      orderBy?: TelephoneNumberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TelephoneNumberConnectionPromise;
  tenant: (where: TenantWhereUniqueInput) => TenantPromise;
  tenants: (
    args?: {
      where?: TenantWhereInput;
      orderBy?: TenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tenant>;
  tenantsConnection: (
    args?: {
      where?: TenantWhereInput;
      orderBy?: TenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TenantConnectionPromise;
  tenantUserRoles: (
    args?: {
      where?: TenantUserRoleWhereInput;
      orderBy?: TenantUserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TenantUserRole>;
  tenantUserRolesConnection: (
    args?: {
      where?: TenantUserRoleWhereInput;
      orderBy?: TenantUserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TenantUserRoleConnectionPromise;
  timeZone: (where: TimeZoneWhereUniqueInput) => TimeZonePromise;
  timeZones: (
    args?: {
      where?: TimeZoneWhereInput;
      orderBy?: TimeZoneOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TimeZone>;
  timeZonesConnection: (
    args?: {
      where?: TimeZoneWhereInput;
      orderBy?: TimeZoneOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TimeZoneConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAddress: (data: AddressCreateInput) => AddressPromise;
  updateAddress: (
    args: { data: AddressUpdateInput; where: AddressWhereUniqueInput }
  ) => AddressPromise;
  updateManyAddresses: (
    args: { data: AddressUpdateManyMutationInput; where?: AddressWhereInput }
  ) => BatchPayloadPromise;
  upsertAddress: (
    args: {
      where: AddressWhereUniqueInput;
      create: AddressCreateInput;
      update: AddressUpdateInput;
    }
  ) => AddressPromise;
  deleteAddress: (where: AddressWhereUniqueInput) => AddressPromise;
  deleteManyAddresses: (where?: AddressWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (
    args: { data: CommentUpdateInput; where: CommentWhereUniqueInput }
  ) => CommentPromise;
  updateManyComments: (
    args: { data: CommentUpdateManyMutationInput; where?: CommentWhereInput }
  ) => BatchPayloadPromise;
  upsertComment: (
    args: {
      where: CommentWhereUniqueInput;
      create: CommentCreateInput;
      update: CommentUpdateInput;
    }
  ) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (
    args: { data: CompanyUpdateInput; where: CompanyWhereUniqueInput }
  ) => CompanyPromise;
  updateManyCompanies: (
    args: { data: CompanyUpdateManyMutationInput; where?: CompanyWhereInput }
  ) => BatchPayloadPromise;
  upsertCompany: (
    args: {
      where: CompanyWhereUniqueInput;
      create: CompanyCreateInput;
      update: CompanyUpdateInput;
    }
  ) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createCoordinate: (data: CoordinateCreateInput) => CoordinatePromise;
  updateCoordinate: (
    args: { data: CoordinateUpdateInput; where: CoordinateWhereUniqueInput }
  ) => CoordinatePromise;
  updateManyCoordinates: (
    args: {
      data: CoordinateUpdateManyMutationInput;
      where?: CoordinateWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCoordinate: (
    args: {
      where: CoordinateWhereUniqueInput;
      create: CoordinateCreateInput;
      update: CoordinateUpdateInput;
    }
  ) => CoordinatePromise;
  deleteCoordinate: (where: CoordinateWhereUniqueInput) => CoordinatePromise;
  deleteManyCoordinates: (where?: CoordinateWhereInput) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (
    args: { data: ImageUpdateInput; where: ImageWhereUniqueInput }
  ) => ImagePromise;
  updateManyImages: (
    args: { data: ImageUpdateManyMutationInput; where?: ImageWhereInput }
  ) => BatchPayloadPromise;
  upsertImage: (
    args: {
      where: ImageWhereUniqueInput;
      create: ImageCreateInput;
      update: ImageUpdateInput;
    }
  ) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createPermission: (data: PermissionCreateInput) => PermissionPromise;
  updatePermission: (
    args: { data: PermissionUpdateInput; where: PermissionWhereUniqueInput }
  ) => PermissionPromise;
  updateManyPermissions: (
    args: {
      data: PermissionUpdateManyMutationInput;
      where?: PermissionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPermission: (
    args: {
      where: PermissionWhereUniqueInput;
      create: PermissionCreateInput;
      update: PermissionUpdateInput;
    }
  ) => PermissionPromise;
  deletePermission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  deleteManyPermissions: (where?: PermissionWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (
    args: { data: PostUpdateInput; where: PostWhereUniqueInput }
  ) => PostPromise;
  updateManyPosts: (
    args: { data: PostUpdateManyMutationInput; where?: PostWhereInput }
  ) => BatchPayloadPromise;
  upsertPost: (
    args: {
      where: PostWhereUniqueInput;
      create: PostCreateInput;
      update: PostUpdateInput;
    }
  ) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createRole: (data: RoleCreateInput) => RolePromise;
  updateRole: (
    args: { data: RoleUpdateInput; where: RoleWhereUniqueInput }
  ) => RolePromise;
  updateManyRoles: (
    args: { data: RoleUpdateManyMutationInput; where?: RoleWhereInput }
  ) => BatchPayloadPromise;
  upsertRole: (
    args: {
      where: RoleWhereUniqueInput;
      create: RoleCreateInput;
      update: RoleUpdateInput;
    }
  ) => RolePromise;
  deleteRole: (where: RoleWhereUniqueInput) => RolePromise;
  deleteManyRoles: (where?: RoleWhereInput) => BatchPayloadPromise;
  createSettings: (data: SettingsCreateInput) => SettingsPromise;
  updateSettings: (
    args: { data: SettingsUpdateInput; where: SettingsWhereUniqueInput }
  ) => SettingsPromise;
  updateManySettingses: (
    args: { data: SettingsUpdateManyMutationInput; where?: SettingsWhereInput }
  ) => BatchPayloadPromise;
  upsertSettings: (
    args: {
      where: SettingsWhereUniqueInput;
      create: SettingsCreateInput;
      update: SettingsUpdateInput;
    }
  ) => SettingsPromise;
  deleteSettings: (where: SettingsWhereUniqueInput) => SettingsPromise;
  deleteManySettingses: (where?: SettingsWhereInput) => BatchPayloadPromise;
  createTelephoneNumber: (
    data: TelephoneNumberCreateInput
  ) => TelephoneNumberPromise;
  updateTelephoneNumber: (
    args: {
      data: TelephoneNumberUpdateInput;
      where: TelephoneNumberWhereUniqueInput;
    }
  ) => TelephoneNumberPromise;
  updateManyTelephoneNumbers: (
    args: {
      data: TelephoneNumberUpdateManyMutationInput;
      where?: TelephoneNumberWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTelephoneNumber: (
    args: {
      where: TelephoneNumberWhereUniqueInput;
      create: TelephoneNumberCreateInput;
      update: TelephoneNumberUpdateInput;
    }
  ) => TelephoneNumberPromise;
  deleteTelephoneNumber: (
    where: TelephoneNumberWhereUniqueInput
  ) => TelephoneNumberPromise;
  deleteManyTelephoneNumbers: (
    where?: TelephoneNumberWhereInput
  ) => BatchPayloadPromise;
  createTenant: (data: TenantCreateInput) => TenantPromise;
  updateTenant: (
    args: { data: TenantUpdateInput; where: TenantWhereUniqueInput }
  ) => TenantPromise;
  updateManyTenants: (
    args: { data: TenantUpdateManyMutationInput; where?: TenantWhereInput }
  ) => BatchPayloadPromise;
  upsertTenant: (
    args: {
      where: TenantWhereUniqueInput;
      create: TenantCreateInput;
      update: TenantUpdateInput;
    }
  ) => TenantPromise;
  deleteTenant: (where: TenantWhereUniqueInput) => TenantPromise;
  deleteManyTenants: (where?: TenantWhereInput) => BatchPayloadPromise;
  createTenantUserRole: (
    data: TenantUserRoleCreateInput
  ) => TenantUserRolePromise;
  updateManyTenantUserRoles: (
    args: {
      data: TenantUserRoleUpdateManyMutationInput;
      where?: TenantUserRoleWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyTenantUserRoles: (
    where?: TenantUserRoleWhereInput
  ) => BatchPayloadPromise;
  createTimeZone: (data: TimeZoneCreateInput) => TimeZonePromise;
  updateTimeZone: (
    args: { data: TimeZoneUpdateInput; where: TimeZoneWhereUniqueInput }
  ) => TimeZonePromise;
  updateManyTimeZones: (
    args: { data: TimeZoneUpdateManyMutationInput; where?: TimeZoneWhereInput }
  ) => BatchPayloadPromise;
  upsertTimeZone: (
    args: {
      where: TimeZoneWhereUniqueInput;
      create: TimeZoneCreateInput;
      update: TimeZoneUpdateInput;
    }
  ) => TimeZonePromise;
  deleteTimeZone: (where: TimeZoneWhereUniqueInput) => TimeZonePromise;
  deleteManyTimeZones: (where?: TimeZoneWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  address: (
    where?: AddressSubscriptionWhereInput
  ) => AddressSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  coordinate: (
    where?: CoordinateSubscriptionWhereInput
  ) => CoordinateSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  permission: (
    where?: PermissionSubscriptionWhereInput
  ) => PermissionSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  role: (
    where?: RoleSubscriptionWhereInput
  ) => RoleSubscriptionPayloadSubscription;
  settings: (
    where?: SettingsSubscriptionWhereInput
  ) => SettingsSubscriptionPayloadSubscription;
  telephoneNumber: (
    where?: TelephoneNumberSubscriptionWhereInput
  ) => TelephoneNumberSubscriptionPayloadSubscription;
  tenant: (
    where?: TenantSubscriptionWhereInput
  ) => TenantSubscriptionPayloadSubscription;
  tenantUserRole: (
    where?: TenantUserRoleSubscriptionWhereInput
  ) => TenantUserRoleSubscriptionPayloadSubscription;
  timeZone: (
    where?: TimeZoneSubscriptionWhereInput
  ) => TimeZoneSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AddressTypes =
  | "BILLING"
  | "BUSINESS"
  | "DELIVERY"
  | "HOME"
  | "VENDOR";

export type Genders = "MALE" | "FEMALE" | "UNKNOWN";

export type AddressOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "street_ASC"
  | "street_DESC"
  | "suite_ASC"
  | "suite_DESC"
  | "city_ASC"
  | "city_DESC"
  | "provinceState_ASC"
  | "provinceState_DESC"
  | "postalcode_ASC"
  | "postalcode_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "url_ASC"
  | "url_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "alt_ASC"
  | "alt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TelephoneNumberOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "type_ASC"
  | "type_DESC"
  | "telephone_ASC"
  | "telephone_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TenantOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isActive_ASC"
  | "isActive_DESC"
  | "domain_ASC"
  | "domain_DESC"
  | "apiKey_ASC"
  | "apiKey_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isActive_ASC"
  | "isActive_DESC"
  | "email_ASC"
  | "email_DESC"
  | "emailVerified_ASC"
  | "emailVerified_DESC"
  | "password_ASC"
  | "password_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "dob_ASC"
  | "dob_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "userData_ASC"
  | "userData_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "lastLoginAt_ASC"
  | "lastLoginAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "token_ASC"
  | "token_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "content_ASC"
  | "content_DESC"
  | "published_ASC"
  | "published_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "content_ASC"
  | "content_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "contactEmail_ASC"
  | "contactEmail_DESC"
  | "domain_ASC"
  | "domain_DESC"
  | "contactPerson_ASC"
  | "contactPerson_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CoordinateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "latitude_ASC"
  | "latitude_DESC"
  | "longitude_ASC"
  | "longitude_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type Permissions =
  | "DRAFT_PRODUCTS"
  | "MANAGE_PROFILE"
  | "MANAGE_PRODUCTS"
  | "APPROVE_PRODUCT_DRAFTS"
  | "MANAGE_TENANT"
  | "MANAGE_TENANT_USERS"
  | "MANAGE_TENANTS"
  | "MANAGE_TENANTS_USERS"
  | "EDIT_PERSONAL_ACCOUNT"
  | "CREATE_USERS"
  | "READ_USERS"
  | "EDIT_USERS"
  | "DELETE_USERS"
  | "CREATE_TENANTS"
  | "READ_TENANTS"
  | "EDIT_TENANTS"
  | "DELETE_TENANTS"
  | "CREATE_SETTINGS"
  | "READ_SETTINGS"
  | "EDIT_SETTINGS"
  | "DELETE_SETTINGS"
  | "CREATE_ORDERS"
  | "READ_ORDERS"
  | "EDIT_ORDERS"
  | "DELETE_ORDERS"
  | "CREATE_INVOICES"
  | "READ_INVOICES"
  | "EDIT_INVOICES"
  | "DELETE_INVOICES"
  | "CREATE_ROLES"
  | "READ_ROLES"
  | "EDIT_ROLES"
  | "DELETE_ROLES"
  | "CREATE_PERMISSIONS"
  | "READ_PERMISSIONS"
  | "EDIT_PERMISSIONS"
  | "DELETE_PERMISSIONS"
  | "CREATE_CATEGORIES"
  | "READ_CATEGORIES"
  | "EDIT_CATEGORIES"
  | "DELETE_CATEGORIES"
  | "CREATE_COUPONS"
  | "READ_COUPONS"
  | "EDIT_COUPONS"
  | "DELETE_COUPONS"
  | "CREATE_PRODUCTS"
  | "READ_PRODUCTS"
  | "EDIT_PRODUCTS"
  | "DELETE_PRODUCTS"
  | "CREATE_REPORTS"
  | "READ_REPORTS"
  | "EDIT_REPORTS"
  | "DELETE_REPORTS"
  | "CREATE_DELIVERY_METHOD"
  | "READ_DELIVERY_METHOD"
  | "EDIT_DELIVERY_METHOD"
  | "DELETE_DELIVERY_METHOD"
  | "CREATE_BILLING_METHOD"
  | "READ_BILLING_METHOD"
  | "EDIT_BILLING_METHOD"
  | "DELETE_BILLING_METHOD";

export type Roles =
  | "CONTRIBUTOR"
  | "ADMINISTRATOR"
  | "ADMIN_TENANT"
  | "SUPER_TENANT"
  | "SUPER_USER";

export type RoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "roleName_ASC"
  | "roleName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PermissionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "permissionName_ASC"
  | "permissionName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SettingsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "data_ASC"
  | "data_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TenantUserRoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TimeZoneOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "offset_ASC"
  | "offset_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type AddressWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AddressWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: AddressTypes;
  type_not?: AddressTypes;
  type_in?: AddressTypes[] | AddressTypes;
  type_not_in?: AddressTypes[] | AddressTypes;
  street?: String;
  street_not?: String;
  street_in?: String[] | String;
  street_not_in?: String[] | String;
  street_lt?: String;
  street_lte?: String;
  street_gt?: String;
  street_gte?: String;
  street_contains?: String;
  street_not_contains?: String;
  street_starts_with?: String;
  street_not_starts_with?: String;
  street_ends_with?: String;
  street_not_ends_with?: String;
  suite?: String;
  suite_not?: String;
  suite_in?: String[] | String;
  suite_not_in?: String[] | String;
  suite_lt?: String;
  suite_lte?: String;
  suite_gt?: String;
  suite_gte?: String;
  suite_contains?: String;
  suite_not_contains?: String;
  suite_starts_with?: String;
  suite_not_starts_with?: String;
  suite_ends_with?: String;
  suite_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  provinceState?: String;
  provinceState_not?: String;
  provinceState_in?: String[] | String;
  provinceState_not_in?: String[] | String;
  provinceState_lt?: String;
  provinceState_lte?: String;
  provinceState_gt?: String;
  provinceState_gte?: String;
  provinceState_contains?: String;
  provinceState_not_contains?: String;
  provinceState_starts_with?: String;
  provinceState_not_starts_with?: String;
  provinceState_ends_with?: String;
  provinceState_not_ends_with?: String;
  postalcode?: String;
  postalcode_not?: String;
  postalcode_in?: String[] | String;
  postalcode_not_in?: String[] | String;
  postalcode_lt?: String;
  postalcode_lte?: String;
  postalcode_gt?: String;
  postalcode_gte?: String;
  postalcode_contains?: String;
  postalcode_not_contains?: String;
  postalcode_starts_with?: String;
  postalcode_not_starts_with?: String;
  postalcode_ends_with?: String;
  postalcode_not_ends_with?: String;
  coordinate?: CoordinateWhereInput;
  timezone?: TimeZoneWhereInput;
  owner?: UserWhereInput;
  AND?: AddressWhereInput[] | AddressWhereInput;
  OR?: AddressWhereInput[] | AddressWhereInput;
  NOT?: AddressWhereInput[] | AddressWhereInput;
}

export interface CoordinateWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  latitude?: String;
  latitude_not?: String;
  latitude_in?: String[] | String;
  latitude_not_in?: String[] | String;
  latitude_lt?: String;
  latitude_lte?: String;
  latitude_gt?: String;
  latitude_gte?: String;
  latitude_contains?: String;
  latitude_not_contains?: String;
  latitude_starts_with?: String;
  latitude_not_starts_with?: String;
  latitude_ends_with?: String;
  latitude_not_ends_with?: String;
  longitude?: String;
  longitude_not?: String;
  longitude_in?: String[] | String;
  longitude_not_in?: String[] | String;
  longitude_lt?: String;
  longitude_lte?: String;
  longitude_gt?: String;
  longitude_gte?: String;
  longitude_contains?: String;
  longitude_not_contains?: String;
  longitude_starts_with?: String;
  longitude_not_starts_with?: String;
  longitude_ends_with?: String;
  longitude_not_ends_with?: String;
  AND?: CoordinateWhereInput[] | CoordinateWhereInput;
  OR?: CoordinateWhereInput[] | CoordinateWhereInput;
  NOT?: CoordinateWhereInput[] | CoordinateWhereInput;
}

export interface TimeZoneWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  offset?: String;
  offset_not?: String;
  offset_in?: String[] | String;
  offset_not_in?: String[] | String;
  offset_lt?: String;
  offset_lte?: String;
  offset_gt?: String;
  offset_gte?: String;
  offset_contains?: String;
  offset_not_contains?: String;
  offset_starts_with?: String;
  offset_not_starts_with?: String;
  offset_ends_with?: String;
  offset_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: TimeZoneWhereInput[] | TimeZoneWhereInput;
  OR?: TimeZoneWhereInput[] | TimeZoneWhereInput;
  NOT?: TimeZoneWhereInput[] | TimeZoneWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isActive?: Boolean;
  isActive_not?: Boolean;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  emailVerified?: Boolean;
  emailVerified_not?: Boolean;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  addresses_every?: AddressWhereInput;
  addresses_some?: AddressWhereInput;
  addresses_none?: AddressWhereInput;
  images_every?: ImageWhereInput;
  images_some?: ImageWhereInput;
  images_none?: ImageWhereInput;
  dob?: DateTimeInput;
  dob_not?: DateTimeInput;
  dob_in?: DateTimeInput[] | DateTimeInput;
  dob_not_in?: DateTimeInput[] | DateTimeInput;
  dob_lt?: DateTimeInput;
  dob_lte?: DateTimeInput;
  dob_gt?: DateTimeInput;
  dob_gte?: DateTimeInput;
  gender?: Genders;
  gender_not?: Genders;
  gender_in?: Genders[] | Genders;
  gender_not_in?: Genders[] | Genders;
  telephoneNumbers_every?: TelephoneNumberWhereInput;
  telephoneNumbers_some?: TelephoneNumberWhereInput;
  telephoneNumbers_none?: TelephoneNumberWhereInput;
  tenants_every?: TenantWhereInput;
  tenants_some?: TenantWhereInput;
  tenants_none?: TenantWhereInput;
  posts_every?: PostWhereInput;
  posts_some?: PostWhereInput;
  posts_none?: PostWhereInput;
  likedPosts_every?: PostWhereInput;
  likedPosts_some?: PostWhereInput;
  likedPosts_none?: PostWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  lastLoginAt?: DateTimeInput;
  lastLoginAt_not?: DateTimeInput;
  lastLoginAt_in?: DateTimeInput[] | DateTimeInput;
  lastLoginAt_not_in?: DateTimeInput[] | DateTimeInput;
  lastLoginAt_lt?: DateTimeInput;
  lastLoginAt_lte?: DateTimeInput;
  lastLoginAt_gt?: DateTimeInput;
  lastLoginAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  token?: String;
  token_not?: String;
  token_in?: String[] | String;
  token_not_in?: String[] | String;
  token_lt?: String;
  token_lte?: String;
  token_gt?: String;
  token_gte?: String;
  token_contains?: String;
  token_not_contains?: String;
  token_starts_with?: String;
  token_not_starts_with?: String;
  token_ends_with?: String;
  token_not_ends_with?: String;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ImageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  alt?: String;
  alt_not?: String;
  alt_in?: String[] | String;
  alt_not_in?: String[] | String;
  alt_lt?: String;
  alt_lte?: String;
  alt_gt?: String;
  alt_gte?: String;
  alt_contains?: String;
  alt_not_contains?: String;
  alt_starts_with?: String;
  alt_not_starts_with?: String;
  alt_ends_with?: String;
  alt_not_ends_with?: String;
  owner?: UserWhereInput;
  AND?: ImageWhereInput[] | ImageWhereInput;
  OR?: ImageWhereInput[] | ImageWhereInput;
  NOT?: ImageWhereInput[] | ImageWhereInput;
}

export interface TelephoneNumberWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  telephone?: String;
  telephone_not?: String;
  telephone_in?: String[] | String;
  telephone_not_in?: String[] | String;
  telephone_lt?: String;
  telephone_lte?: String;
  telephone_gt?: String;
  telephone_gte?: String;
  telephone_contains?: String;
  telephone_not_contains?: String;
  telephone_starts_with?: String;
  telephone_not_starts_with?: String;
  telephone_ends_with?: String;
  telephone_not_ends_with?: String;
  owner?: UserWhereInput;
  AND?: TelephoneNumberWhereInput[] | TelephoneNumberWhereInput;
  OR?: TelephoneNumberWhereInput[] | TelephoneNumberWhereInput;
  NOT?: TelephoneNumberWhereInput[] | TelephoneNumberWhereInput;
}

export interface TenantWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isActive?: Boolean;
  isActive_not?: Boolean;
  domain?: String;
  domain_not?: String;
  domain_in?: String[] | String;
  domain_not_in?: String[] | String;
  domain_lt?: String;
  domain_lte?: String;
  domain_gt?: String;
  domain_gte?: String;
  domain_contains?: String;
  domain_not_contains?: String;
  domain_starts_with?: String;
  domain_not_starts_with?: String;
  domain_ends_with?: String;
  domain_not_ends_with?: String;
  apiKey?: String;
  apiKey_not?: String;
  apiKey_in?: String[] | String;
  apiKey_not_in?: String[] | String;
  apiKey_lt?: String;
  apiKey_lte?: String;
  apiKey_gt?: String;
  apiKey_gte?: String;
  apiKey_contains?: String;
  apiKey_not_contains?: String;
  apiKey_starts_with?: String;
  apiKey_not_starts_with?: String;
  apiKey_ends_with?: String;
  apiKey_not_ends_with?: String;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  company?: CompanyWhereInput;
  parent?: TenantWhereInput;
  settings?: SettingsWhereInput;
  AND?: TenantWhereInput[] | TenantWhereInput;
  OR?: TenantWhereInput[] | TenantWhereInput;
  NOT?: TenantWhereInput[] | TenantWhereInput;
}

export interface CompanyWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  address?: AddressWhereInput;
  contactNumber?: TelephoneNumberWhereInput;
  contactEmail?: String;
  contactEmail_not?: String;
  contactEmail_in?: String[] | String;
  contactEmail_not_in?: String[] | String;
  contactEmail_lt?: String;
  contactEmail_lte?: String;
  contactEmail_gt?: String;
  contactEmail_gte?: String;
  contactEmail_contains?: String;
  contactEmail_not_contains?: String;
  contactEmail_starts_with?: String;
  contactEmail_not_starts_with?: String;
  contactEmail_ends_with?: String;
  contactEmail_not_ends_with?: String;
  domain?: String;
  domain_not?: String;
  domain_in?: String[] | String;
  domain_not_in?: String[] | String;
  domain_lt?: String;
  domain_lte?: String;
  domain_gt?: String;
  domain_gte?: String;
  domain_contains?: String;
  domain_not_contains?: String;
  domain_starts_with?: String;
  domain_not_starts_with?: String;
  domain_ends_with?: String;
  domain_not_ends_with?: String;
  contactPerson?: String;
  contactPerson_not?: String;
  contactPerson_in?: String[] | String;
  contactPerson_not_in?: String[] | String;
  contactPerson_lt?: String;
  contactPerson_lte?: String;
  contactPerson_gt?: String;
  contactPerson_gte?: String;
  contactPerson_contains?: String;
  contactPerson_not_contains?: String;
  contactPerson_starts_with?: String;
  contactPerson_not_starts_with?: String;
  contactPerson_ends_with?: String;
  contactPerson_not_ends_with?: String;
  AND?: CompanyWhereInput[] | CompanyWhereInput;
  OR?: CompanyWhereInput[] | CompanyWhereInput;
  NOT?: CompanyWhereInput[] | CompanyWhereInput;
}

export interface SettingsWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  tenant?: TenantWhereInput;
  AND?: SettingsWhereInput[] | SettingsWhereInput;
  OR?: SettingsWhereInput[] | SettingsWhereInput;
  NOT?: SettingsWhereInput[] | SettingsWhereInput;
}

export interface PostWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  published?: Boolean;
  published_not?: Boolean;
  author?: UserWhereInput;
  likedBy_every?: UserWhereInput;
  likedBy_some?: UserWhereInput;
  likedBy_none?: UserWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PostWhereInput[] | PostWhereInput;
  OR?: PostWhereInput[] | PostWhereInput;
  NOT?: PostWhereInput[] | PostWhereInput;
}

export interface CommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  post?: PostWhereInput;
  author?: UserWhereInput;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CommentWhereInput[] | CommentWhereInput;
  OR?: CommentWhereInput[] | CommentWhereInput;
  NOT?: CommentWhereInput[] | CommentWhereInput;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type CoordinateWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ImageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PermissionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface RoleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  roleName?: Roles;
  roleName_not?: Roles;
  roleName_in?: Roles[] | Roles;
  roleName_not_in?: Roles[] | Roles;
  permissions_every?: PermissionWhereInput;
  permissions_some?: PermissionWhereInput;
  permissions_none?: PermissionWhereInput;
  AND?: RoleWhereInput[] | RoleWhereInput;
  OR?: RoleWhereInput[] | RoleWhereInput;
  NOT?: RoleWhereInput[] | RoleWhereInput;
}

export interface PermissionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  permissionName?: Permissions;
  permissionName_not?: Permissions;
  permissionName_in?: Permissions[] | Permissions;
  permissionName_not_in?: Permissions[] | Permissions;
  roles_every?: RoleWhereInput;
  roles_some?: RoleWhereInput;
  roles_none?: RoleWhereInput;
  AND?: PermissionWhereInput[] | PermissionWhereInput;
  OR?: PermissionWhereInput[] | PermissionWhereInput;
  NOT?: PermissionWhereInput[] | PermissionWhereInput;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export type RoleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SettingsWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TelephoneNumberWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TenantWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  domain?: String;
}>;

export interface TenantUserRoleWhereInput {
  tenant?: TenantWhereInput;
  user?: UserWhereInput;
  AND?: TenantUserRoleWhereInput[] | TenantUserRoleWhereInput;
  OR?: TenantUserRoleWhereInput[] | TenantUserRoleWhereInput;
  NOT?: TenantUserRoleWhereInput[] | TenantUserRoleWhereInput;
}

export type TimeZoneWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface AddressCreateInput {
  type: AddressTypes;
  street: String;
  suite?: String;
  city: String;
  provinceState: String;
  postalcode: String;
  coordinate?: CoordinateCreateOneInput;
  timezone?: TimeZoneCreateOneInput;
  owner: UserCreateOneWithoutAddressesInput;
}

export interface CoordinateCreateOneInput {
  create?: CoordinateCreateInput;
  connect?: CoordinateWhereUniqueInput;
}

export interface CoordinateCreateInput {
  latitude: String;
  longitude: String;
}

export interface TimeZoneCreateOneInput {
  create?: TimeZoneCreateInput;
  connect?: TimeZoneWhereUniqueInput;
}

export interface TimeZoneCreateInput {
  offset?: String;
  description?: String;
}

export interface UserCreateOneWithoutAddressesInput {
  create?: UserCreateWithoutAddressesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutAddressesInput {
  isActive?: Boolean;
  email: String;
  emailVerified?: Boolean;
  password: String;
  firstName?: String;
  lastName?: String;
  images?: ImageCreateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberCreateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantCreateManyWithoutUsersInput;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface ImageCreateManyWithoutOwnerInput {
  create?: ImageCreateWithoutOwnerInput[] | ImageCreateWithoutOwnerInput;
  connect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
}

export interface ImageCreateWithoutOwnerInput {
  url: String;
  name?: String;
  description?: String;
  alt?: String;
}

export interface TelephoneNumberCreateManyWithoutOwnerInput {
  create?:
    | TelephoneNumberCreateWithoutOwnerInput[]
    | TelephoneNumberCreateWithoutOwnerInput;
  connect?: TelephoneNumberWhereUniqueInput[] | TelephoneNumberWhereUniqueInput;
}

export interface TelephoneNumberCreateWithoutOwnerInput {
  type: String;
  telephone: String;
}

export interface TenantCreateManyWithoutUsersInput {
  create?: TenantCreateWithoutUsersInput[] | TenantCreateWithoutUsersInput;
  connect?: TenantWhereUniqueInput[] | TenantWhereUniqueInput;
}

export interface TenantCreateWithoutUsersInput {
  isActive?: Boolean;
  domain: String;
  apiKey?: String;
  company: CompanyCreateOneInput;
  parent?: TenantCreateOneInput;
  settings?: SettingsCreateOneWithoutTenantInput;
}

export interface CompanyCreateOneInput {
  create?: CompanyCreateInput;
  connect?: CompanyWhereUniqueInput;
}

export interface CompanyCreateInput {
  name: String;
  address: AddressCreateOneInput;
  contactNumber: TelephoneNumberCreateOneInput;
  contactEmail: String;
  domain: String;
  contactPerson?: String;
}

export interface AddressCreateOneInput {
  create?: AddressCreateInput;
  connect?: AddressWhereUniqueInput;
}

export interface TelephoneNumberCreateOneInput {
  create?: TelephoneNumberCreateInput;
  connect?: TelephoneNumberWhereUniqueInput;
}

export interface TelephoneNumberCreateInput {
  type: String;
  telephone: String;
  owner: UserCreateOneWithoutTelephoneNumbersInput;
}

export interface UserCreateOneWithoutTelephoneNumbersInput {
  create?: UserCreateWithoutTelephoneNumbersInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutTelephoneNumbersInput {
  isActive?: Boolean;
  email: String;
  emailVerified?: Boolean;
  password: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressCreateManyWithoutOwnerInput;
  images?: ImageCreateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  userData?: Json;
  tenants?: TenantCreateManyWithoutUsersInput;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface AddressCreateManyWithoutOwnerInput {
  create?: AddressCreateWithoutOwnerInput[] | AddressCreateWithoutOwnerInput;
  connect?: AddressWhereUniqueInput[] | AddressWhereUniqueInput;
}

export interface AddressCreateWithoutOwnerInput {
  type: AddressTypes;
  street: String;
  suite?: String;
  city: String;
  provinceState: String;
  postalcode: String;
  coordinate?: CoordinateCreateOneInput;
  timezone?: TimeZoneCreateOneInput;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
}

export interface PostCreateWithoutAuthorInput {
  title: String;
  content?: String;
  published?: Boolean;
  likedBy?: UserCreateManyWithoutLikedPostsInput;
  comments?: CommentCreateManyWithoutPostInput;
}

export interface UserCreateManyWithoutLikedPostsInput {
  create?:
    | UserCreateWithoutLikedPostsInput[]
    | UserCreateWithoutLikedPostsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutLikedPostsInput {
  isActive?: Boolean;
  email: String;
  emailVerified?: Boolean;
  password: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressCreateManyWithoutOwnerInput;
  images?: ImageCreateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberCreateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantCreateManyWithoutUsersInput;
  posts?: PostCreateManyWithoutAuthorInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface CommentCreateManyWithoutAuthorInput {
  create?: CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface CommentCreateWithoutAuthorInput {
  content?: String;
  post: PostCreateOneWithoutCommentsInput;
}

export interface PostCreateOneWithoutCommentsInput {
  create?: PostCreateWithoutCommentsInput;
  connect?: PostWhereUniqueInput;
}

export interface PostCreateWithoutCommentsInput {
  title: String;
  content?: String;
  published?: Boolean;
  author: UserCreateOneWithoutPostsInput;
  likedBy?: UserCreateManyWithoutLikedPostsInput;
}

export interface UserCreateOneWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutPostsInput {
  isActive?: Boolean;
  email: String;
  emailVerified?: Boolean;
  password: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressCreateManyWithoutOwnerInput;
  images?: ImageCreateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberCreateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantCreateManyWithoutUsersInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface PostCreateManyWithoutLikedByInput {
  create?: PostCreateWithoutLikedByInput[] | PostCreateWithoutLikedByInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
}

export interface PostCreateWithoutLikedByInput {
  title: String;
  content?: String;
  published?: Boolean;
  author: UserCreateOneWithoutPostsInput;
  comments?: CommentCreateManyWithoutPostInput;
}

export interface CommentCreateManyWithoutPostInput {
  create?: CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface CommentCreateWithoutPostInput {
  content?: String;
  author: UserCreateOneWithoutCommentsInput;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: UserCreateWithoutCommentsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutCommentsInput {
  isActive?: Boolean;
  email: String;
  emailVerified?: Boolean;
  password: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressCreateManyWithoutOwnerInput;
  images?: ImageCreateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberCreateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantCreateManyWithoutUsersInput;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface TenantCreateOneInput {
  create?: TenantCreateInput;
  connect?: TenantWhereUniqueInput;
}

export interface TenantCreateInput {
  isActive?: Boolean;
  domain: String;
  apiKey?: String;
  users?: UserCreateManyWithoutTenantsInput;
  company: CompanyCreateOneInput;
  parent?: TenantCreateOneInput;
  settings?: SettingsCreateOneWithoutTenantInput;
}

export interface UserCreateManyWithoutTenantsInput {
  create?: UserCreateWithoutTenantsInput[] | UserCreateWithoutTenantsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutTenantsInput {
  isActive?: Boolean;
  email: String;
  emailVerified?: Boolean;
  password: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressCreateManyWithoutOwnerInput;
  images?: ImageCreateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberCreateManyWithoutOwnerInput;
  userData?: Json;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface SettingsCreateOneWithoutTenantInput {
  create?: SettingsCreateWithoutTenantInput;
  connect?: SettingsWhereUniqueInput;
}

export interface SettingsCreateWithoutTenantInput {
  data?: Json;
}

export interface AddressUpdateInput {
  type?: AddressTypes;
  street?: String;
  suite?: String;
  city?: String;
  provinceState?: String;
  postalcode?: String;
  coordinate?: CoordinateUpdateOneInput;
  timezone?: TimeZoneUpdateOneInput;
  owner?: UserUpdateOneRequiredWithoutAddressesInput;
}

export interface CoordinateUpdateOneInput {
  create?: CoordinateCreateInput;
  update?: CoordinateUpdateDataInput;
  upsert?: CoordinateUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CoordinateWhereUniqueInput;
}

export interface CoordinateUpdateDataInput {
  latitude?: String;
  longitude?: String;
}

export interface CoordinateUpsertNestedInput {
  update: CoordinateUpdateDataInput;
  create: CoordinateCreateInput;
}

export interface TimeZoneUpdateOneInput {
  create?: TimeZoneCreateInput;
  update?: TimeZoneUpdateDataInput;
  upsert?: TimeZoneUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TimeZoneWhereUniqueInput;
}

export interface TimeZoneUpdateDataInput {
  offset?: String;
  description?: String;
}

export interface TimeZoneUpsertNestedInput {
  update: TimeZoneUpdateDataInput;
  create: TimeZoneCreateInput;
}

export interface UserUpdateOneRequiredWithoutAddressesInput {
  create?: UserCreateWithoutAddressesInput;
  update?: UserUpdateWithoutAddressesDataInput;
  upsert?: UserUpsertWithoutAddressesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutAddressesDataInput {
  isActive?: Boolean;
  email?: String;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  images?: ImageUpdateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberUpdateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantUpdateManyWithoutUsersInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface ImageUpdateManyWithoutOwnerInput {
  create?: ImageCreateWithoutOwnerInput[] | ImageCreateWithoutOwnerInput;
  delete?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  connect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  disconnect?: ImageWhereUniqueInput[] | ImageWhereUniqueInput;
  update?:
    | ImageUpdateWithWhereUniqueWithoutOwnerInput[]
    | ImageUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | ImageUpsertWithWhereUniqueWithoutOwnerInput[]
    | ImageUpsertWithWhereUniqueWithoutOwnerInput;
  deleteMany?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  updateMany?:
    | ImageUpdateManyWithWhereNestedInput[]
    | ImageUpdateManyWithWhereNestedInput;
}

export interface ImageUpdateWithWhereUniqueWithoutOwnerInput {
  where: ImageWhereUniqueInput;
  data: ImageUpdateWithoutOwnerDataInput;
}

export interface ImageUpdateWithoutOwnerDataInput {
  url?: String;
  name?: String;
  description?: String;
  alt?: String;
}

export interface ImageUpsertWithWhereUniqueWithoutOwnerInput {
  where: ImageWhereUniqueInput;
  update: ImageUpdateWithoutOwnerDataInput;
  create: ImageCreateWithoutOwnerInput;
}

export interface ImageScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  alt?: String;
  alt_not?: String;
  alt_in?: String[] | String;
  alt_not_in?: String[] | String;
  alt_lt?: String;
  alt_lte?: String;
  alt_gt?: String;
  alt_gte?: String;
  alt_contains?: String;
  alt_not_contains?: String;
  alt_starts_with?: String;
  alt_not_starts_with?: String;
  alt_ends_with?: String;
  alt_not_ends_with?: String;
  AND?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  OR?: ImageScalarWhereInput[] | ImageScalarWhereInput;
  NOT?: ImageScalarWhereInput[] | ImageScalarWhereInput;
}

export interface ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput;
  data: ImageUpdateManyDataInput;
}

export interface ImageUpdateManyDataInput {
  url?: String;
  name?: String;
  description?: String;
  alt?: String;
}

export interface TelephoneNumberUpdateManyWithoutOwnerInput {
  create?:
    | TelephoneNumberCreateWithoutOwnerInput[]
    | TelephoneNumberCreateWithoutOwnerInput;
  delete?: TelephoneNumberWhereUniqueInput[] | TelephoneNumberWhereUniqueInput;
  connect?: TelephoneNumberWhereUniqueInput[] | TelephoneNumberWhereUniqueInput;
  disconnect?:
    | TelephoneNumberWhereUniqueInput[]
    | TelephoneNumberWhereUniqueInput;
  update?:
    | TelephoneNumberUpdateWithWhereUniqueWithoutOwnerInput[]
    | TelephoneNumberUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | TelephoneNumberUpsertWithWhereUniqueWithoutOwnerInput[]
    | TelephoneNumberUpsertWithWhereUniqueWithoutOwnerInput;
  deleteMany?:
    | TelephoneNumberScalarWhereInput[]
    | TelephoneNumberScalarWhereInput;
  updateMany?:
    | TelephoneNumberUpdateManyWithWhereNestedInput[]
    | TelephoneNumberUpdateManyWithWhereNestedInput;
}

export interface TelephoneNumberUpdateWithWhereUniqueWithoutOwnerInput {
  where: TelephoneNumberWhereUniqueInput;
  data: TelephoneNumberUpdateWithoutOwnerDataInput;
}

export interface TelephoneNumberUpdateWithoutOwnerDataInput {
  type?: String;
  telephone?: String;
}

export interface TelephoneNumberUpsertWithWhereUniqueWithoutOwnerInput {
  where: TelephoneNumberWhereUniqueInput;
  update: TelephoneNumberUpdateWithoutOwnerDataInput;
  create: TelephoneNumberCreateWithoutOwnerInput;
}

export interface TelephoneNumberScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: String;
  type_not?: String;
  type_in?: String[] | String;
  type_not_in?: String[] | String;
  type_lt?: String;
  type_lte?: String;
  type_gt?: String;
  type_gte?: String;
  type_contains?: String;
  type_not_contains?: String;
  type_starts_with?: String;
  type_not_starts_with?: String;
  type_ends_with?: String;
  type_not_ends_with?: String;
  telephone?: String;
  telephone_not?: String;
  telephone_in?: String[] | String;
  telephone_not_in?: String[] | String;
  telephone_lt?: String;
  telephone_lte?: String;
  telephone_gt?: String;
  telephone_gte?: String;
  telephone_contains?: String;
  telephone_not_contains?: String;
  telephone_starts_with?: String;
  telephone_not_starts_with?: String;
  telephone_ends_with?: String;
  telephone_not_ends_with?: String;
  AND?: TelephoneNumberScalarWhereInput[] | TelephoneNumberScalarWhereInput;
  OR?: TelephoneNumberScalarWhereInput[] | TelephoneNumberScalarWhereInput;
  NOT?: TelephoneNumberScalarWhereInput[] | TelephoneNumberScalarWhereInput;
}

export interface TelephoneNumberUpdateManyWithWhereNestedInput {
  where: TelephoneNumberScalarWhereInput;
  data: TelephoneNumberUpdateManyDataInput;
}

export interface TelephoneNumberUpdateManyDataInput {
  type?: String;
  telephone?: String;
}

export interface TenantUpdateManyWithoutUsersInput {
  create?: TenantCreateWithoutUsersInput[] | TenantCreateWithoutUsersInput;
  delete?: TenantWhereUniqueInput[] | TenantWhereUniqueInput;
  connect?: TenantWhereUniqueInput[] | TenantWhereUniqueInput;
  disconnect?: TenantWhereUniqueInput[] | TenantWhereUniqueInput;
  update?:
    | TenantUpdateWithWhereUniqueWithoutUsersInput[]
    | TenantUpdateWithWhereUniqueWithoutUsersInput;
  upsert?:
    | TenantUpsertWithWhereUniqueWithoutUsersInput[]
    | TenantUpsertWithWhereUniqueWithoutUsersInput;
  deleteMany?: TenantScalarWhereInput[] | TenantScalarWhereInput;
  updateMany?:
    | TenantUpdateManyWithWhereNestedInput[]
    | TenantUpdateManyWithWhereNestedInput;
}

export interface TenantUpdateWithWhereUniqueWithoutUsersInput {
  where: TenantWhereUniqueInput;
  data: TenantUpdateWithoutUsersDataInput;
}

export interface TenantUpdateWithoutUsersDataInput {
  isActive?: Boolean;
  domain?: String;
  apiKey?: String;
  company?: CompanyUpdateOneRequiredInput;
  parent?: TenantUpdateOneInput;
  settings?: SettingsUpdateOneWithoutTenantInput;
}

export interface CompanyUpdateOneRequiredInput {
  create?: CompanyCreateInput;
  update?: CompanyUpdateDataInput;
  upsert?: CompanyUpsertNestedInput;
  connect?: CompanyWhereUniqueInput;
}

export interface CompanyUpdateDataInput {
  name?: String;
  address?: AddressUpdateOneRequiredInput;
  contactNumber?: TelephoneNumberUpdateOneRequiredInput;
  contactEmail?: String;
  domain?: String;
  contactPerson?: String;
}

export interface AddressUpdateOneRequiredInput {
  create?: AddressCreateInput;
  update?: AddressUpdateDataInput;
  upsert?: AddressUpsertNestedInput;
  connect?: AddressWhereUniqueInput;
}

export interface AddressUpdateDataInput {
  type?: AddressTypes;
  street?: String;
  suite?: String;
  city?: String;
  provinceState?: String;
  postalcode?: String;
  coordinate?: CoordinateUpdateOneInput;
  timezone?: TimeZoneUpdateOneInput;
  owner?: UserUpdateOneRequiredWithoutAddressesInput;
}

export interface AddressUpsertNestedInput {
  update: AddressUpdateDataInput;
  create: AddressCreateInput;
}

export interface TelephoneNumberUpdateOneRequiredInput {
  create?: TelephoneNumberCreateInput;
  update?: TelephoneNumberUpdateDataInput;
  upsert?: TelephoneNumberUpsertNestedInput;
  connect?: TelephoneNumberWhereUniqueInput;
}

export interface TelephoneNumberUpdateDataInput {
  type?: String;
  telephone?: String;
  owner?: UserUpdateOneRequiredWithoutTelephoneNumbersInput;
}

export interface UserUpdateOneRequiredWithoutTelephoneNumbersInput {
  create?: UserCreateWithoutTelephoneNumbersInput;
  update?: UserUpdateWithoutTelephoneNumbersDataInput;
  upsert?: UserUpsertWithoutTelephoneNumbersInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutTelephoneNumbersDataInput {
  isActive?: Boolean;
  email?: String;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressUpdateManyWithoutOwnerInput;
  images?: ImageUpdateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  userData?: Json;
  tenants?: TenantUpdateManyWithoutUsersInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface AddressUpdateManyWithoutOwnerInput {
  create?: AddressCreateWithoutOwnerInput[] | AddressCreateWithoutOwnerInput;
  delete?: AddressWhereUniqueInput[] | AddressWhereUniqueInput;
  connect?: AddressWhereUniqueInput[] | AddressWhereUniqueInput;
  disconnect?: AddressWhereUniqueInput[] | AddressWhereUniqueInput;
  update?:
    | AddressUpdateWithWhereUniqueWithoutOwnerInput[]
    | AddressUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | AddressUpsertWithWhereUniqueWithoutOwnerInput[]
    | AddressUpsertWithWhereUniqueWithoutOwnerInput;
  deleteMany?: AddressScalarWhereInput[] | AddressScalarWhereInput;
  updateMany?:
    | AddressUpdateManyWithWhereNestedInput[]
    | AddressUpdateManyWithWhereNestedInput;
}

export interface AddressUpdateWithWhereUniqueWithoutOwnerInput {
  where: AddressWhereUniqueInput;
  data: AddressUpdateWithoutOwnerDataInput;
}

export interface AddressUpdateWithoutOwnerDataInput {
  type?: AddressTypes;
  street?: String;
  suite?: String;
  city?: String;
  provinceState?: String;
  postalcode?: String;
  coordinate?: CoordinateUpdateOneInput;
  timezone?: TimeZoneUpdateOneInput;
}

export interface AddressUpsertWithWhereUniqueWithoutOwnerInput {
  where: AddressWhereUniqueInput;
  update: AddressUpdateWithoutOwnerDataInput;
  create: AddressCreateWithoutOwnerInput;
}

export interface AddressScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  type?: AddressTypes;
  type_not?: AddressTypes;
  type_in?: AddressTypes[] | AddressTypes;
  type_not_in?: AddressTypes[] | AddressTypes;
  street?: String;
  street_not?: String;
  street_in?: String[] | String;
  street_not_in?: String[] | String;
  street_lt?: String;
  street_lte?: String;
  street_gt?: String;
  street_gte?: String;
  street_contains?: String;
  street_not_contains?: String;
  street_starts_with?: String;
  street_not_starts_with?: String;
  street_ends_with?: String;
  street_not_ends_with?: String;
  suite?: String;
  suite_not?: String;
  suite_in?: String[] | String;
  suite_not_in?: String[] | String;
  suite_lt?: String;
  suite_lte?: String;
  suite_gt?: String;
  suite_gte?: String;
  suite_contains?: String;
  suite_not_contains?: String;
  suite_starts_with?: String;
  suite_not_starts_with?: String;
  suite_ends_with?: String;
  suite_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  provinceState?: String;
  provinceState_not?: String;
  provinceState_in?: String[] | String;
  provinceState_not_in?: String[] | String;
  provinceState_lt?: String;
  provinceState_lte?: String;
  provinceState_gt?: String;
  provinceState_gte?: String;
  provinceState_contains?: String;
  provinceState_not_contains?: String;
  provinceState_starts_with?: String;
  provinceState_not_starts_with?: String;
  provinceState_ends_with?: String;
  provinceState_not_ends_with?: String;
  postalcode?: String;
  postalcode_not?: String;
  postalcode_in?: String[] | String;
  postalcode_not_in?: String[] | String;
  postalcode_lt?: String;
  postalcode_lte?: String;
  postalcode_gt?: String;
  postalcode_gte?: String;
  postalcode_contains?: String;
  postalcode_not_contains?: String;
  postalcode_starts_with?: String;
  postalcode_not_starts_with?: String;
  postalcode_ends_with?: String;
  postalcode_not_ends_with?: String;
  AND?: AddressScalarWhereInput[] | AddressScalarWhereInput;
  OR?: AddressScalarWhereInput[] | AddressScalarWhereInput;
  NOT?: AddressScalarWhereInput[] | AddressScalarWhereInput;
}

export interface AddressUpdateManyWithWhereNestedInput {
  where: AddressScalarWhereInput;
  data: AddressUpdateManyDataInput;
}

export interface AddressUpdateManyDataInput {
  type?: AddressTypes;
  street?: String;
  suite?: String;
  city?: String;
  provinceState?: String;
  postalcode?: String;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  update?:
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: PostScalarWhereInput[] | PostScalarWhereInput;
  updateMany?:
    | PostUpdateManyWithWhereNestedInput[]
    | PostUpdateManyWithWhereNestedInput;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface PostUpdateWithoutAuthorDataInput {
  title?: String;
  content?: String;
  published?: Boolean;
  likedBy?: UserUpdateManyWithoutLikedPostsInput;
  comments?: CommentUpdateManyWithoutPostInput;
}

export interface UserUpdateManyWithoutLikedPostsInput {
  create?:
    | UserCreateWithoutLikedPostsInput[]
    | UserCreateWithoutLikedPostsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutLikedPostsInput[]
    | UserUpdateWithWhereUniqueWithoutLikedPostsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutLikedPostsInput[]
    | UserUpsertWithWhereUniqueWithoutLikedPostsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikedPostsDataInput;
}

export interface UserUpdateWithoutLikedPostsDataInput {
  isActive?: Boolean;
  email?: String;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressUpdateManyWithoutOwnerInput;
  images?: ImageUpdateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberUpdateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantUpdateManyWithoutUsersInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface CommentUpdateManyWithoutAuthorInput {
  create?: CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    | CommentUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    | CommentUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutAuthorDataInput;
}

export interface CommentUpdateWithoutAuthorDataInput {
  content?: String;
  post?: PostUpdateOneRequiredWithoutCommentsInput;
}

export interface PostUpdateOneRequiredWithoutCommentsInput {
  create?: PostCreateWithoutCommentsInput;
  update?: PostUpdateWithoutCommentsDataInput;
  upsert?: PostUpsertWithoutCommentsInput;
  connect?: PostWhereUniqueInput;
}

export interface PostUpdateWithoutCommentsDataInput {
  title?: String;
  content?: String;
  published?: Boolean;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  likedBy?: UserUpdateManyWithoutLikedPostsInput;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  update?: UserUpdateWithoutPostsDataInput;
  upsert?: UserUpsertWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutPostsDataInput {
  isActive?: Boolean;
  email?: String;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressUpdateManyWithoutOwnerInput;
  images?: ImageUpdateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberUpdateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantUpdateManyWithoutUsersInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface PostUpdateManyWithoutLikedByInput {
  create?: PostCreateWithoutLikedByInput[] | PostCreateWithoutLikedByInput;
  delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  update?:
    | PostUpdateWithWhereUniqueWithoutLikedByInput[]
    | PostUpdateWithWhereUniqueWithoutLikedByInput;
  upsert?:
    | PostUpsertWithWhereUniqueWithoutLikedByInput[]
    | PostUpsertWithWhereUniqueWithoutLikedByInput;
  deleteMany?: PostScalarWhereInput[] | PostScalarWhereInput;
  updateMany?:
    | PostUpdateManyWithWhereNestedInput[]
    | PostUpdateManyWithWhereNestedInput;
}

export interface PostUpdateWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutLikedByDataInput;
}

export interface PostUpdateWithoutLikedByDataInput {
  title?: String;
  content?: String;
  published?: Boolean;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  comments?: CommentUpdateManyWithoutPostInput;
}

export interface CommentUpdateManyWithoutPostInput {
  create?: CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutPostInput[]
    | CommentUpdateWithWhereUniqueWithoutPostInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutPostInput[]
    | CommentUpsertWithWhereUniqueWithoutPostInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutPostDataInput;
}

export interface CommentUpdateWithoutPostDataInput {
  content?: String;
  author?: UserUpdateOneRequiredWithoutCommentsInput;
}

export interface UserUpdateOneRequiredWithoutCommentsInput {
  create?: UserCreateWithoutCommentsInput;
  update?: UserUpdateWithoutCommentsDataInput;
  upsert?: UserUpsertWithoutCommentsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutCommentsDataInput {
  isActive?: Boolean;
  email?: String;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressUpdateManyWithoutOwnerInput;
  images?: ImageUpdateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberUpdateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantUpdateManyWithoutUsersInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutPostDataInput;
  create: CommentCreateWithoutPostInput;
}

export interface CommentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  OR?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  NOT?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  content?: String;
}

export interface PostUpsertWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutLikedByDataInput;
  create: PostCreateWithoutLikedByInput;
}

export interface PostScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  content?: String;
  content_not?: String;
  content_in?: String[] | String;
  content_not_in?: String[] | String;
  content_lt?: String;
  content_lte?: String;
  content_gt?: String;
  content_gte?: String;
  content_contains?: String;
  content_not_contains?: String;
  content_starts_with?: String;
  content_not_starts_with?: String;
  content_ends_with?: String;
  content_not_ends_with?: String;
  published?: Boolean;
  published_not?: Boolean;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: PostScalarWhereInput[] | PostScalarWhereInput;
  OR?: PostScalarWhereInput[] | PostScalarWhereInput;
  NOT?: PostScalarWhereInput[] | PostScalarWhereInput;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface PostUpdateManyDataInput {
  title?: String;
  content?: String;
  published?: Boolean;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput;
  create: PostCreateWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutAuthorDataInput;
  create: CommentCreateWithoutAuthorInput;
}

export interface UserUpsertWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikedPostsDataInput;
  create: UserCreateWithoutLikedPostsInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isActive?: Boolean;
  isActive_not?: Boolean;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  emailVerified?: Boolean;
  emailVerified_not?: Boolean;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  dob?: DateTimeInput;
  dob_not?: DateTimeInput;
  dob_in?: DateTimeInput[] | DateTimeInput;
  dob_not_in?: DateTimeInput[] | DateTimeInput;
  dob_lt?: DateTimeInput;
  dob_lte?: DateTimeInput;
  dob_gt?: DateTimeInput;
  dob_gte?: DateTimeInput;
  gender?: Genders;
  gender_not?: Genders;
  gender_in?: Genders[] | Genders;
  gender_not_in?: Genders[] | Genders;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  lastLoginAt?: DateTimeInput;
  lastLoginAt_not?: DateTimeInput;
  lastLoginAt_in?: DateTimeInput[] | DateTimeInput;
  lastLoginAt_not_in?: DateTimeInput[] | DateTimeInput;
  lastLoginAt_lt?: DateTimeInput;
  lastLoginAt_lte?: DateTimeInput;
  lastLoginAt_gt?: DateTimeInput;
  lastLoginAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  token?: String;
  token_not?: String;
  token_in?: String[] | String;
  token_not_in?: String[] | String;
  token_lt?: String;
  token_lte?: String;
  token_gt?: String;
  token_gte?: String;
  token_contains?: String;
  token_not_contains?: String;
  token_starts_with?: String;
  token_not_starts_with?: String;
  token_ends_with?: String;
  token_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  isActive?: Boolean;
  email?: String;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  dob?: DateTimeInput;
  gender?: Genders;
  userData?: Json;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface UserUpsertWithoutTelephoneNumbersInput {
  update: UserUpdateWithoutTelephoneNumbersDataInput;
  create: UserCreateWithoutTelephoneNumbersInput;
}

export interface TelephoneNumberUpsertNestedInput {
  update: TelephoneNumberUpdateDataInput;
  create: TelephoneNumberCreateInput;
}

export interface CompanyUpsertNestedInput {
  update: CompanyUpdateDataInput;
  create: CompanyCreateInput;
}

export interface TenantUpdateOneInput {
  create?: TenantCreateInput;
  update?: TenantUpdateDataInput;
  upsert?: TenantUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TenantWhereUniqueInput;
}

export interface TenantUpdateDataInput {
  isActive?: Boolean;
  domain?: String;
  apiKey?: String;
  users?: UserUpdateManyWithoutTenantsInput;
  company?: CompanyUpdateOneRequiredInput;
  parent?: TenantUpdateOneInput;
  settings?: SettingsUpdateOneWithoutTenantInput;
}

export interface UserUpdateManyWithoutTenantsInput {
  create?: UserCreateWithoutTenantsInput[] | UserCreateWithoutTenantsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutTenantsInput[]
    | UserUpdateWithWhereUniqueWithoutTenantsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutTenantsInput[]
    | UserUpsertWithWhereUniqueWithoutTenantsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutTenantsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTenantsDataInput;
}

export interface UserUpdateWithoutTenantsDataInput {
  isActive?: Boolean;
  email?: String;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressUpdateManyWithoutOwnerInput;
  images?: ImageUpdateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberUpdateManyWithoutOwnerInput;
  userData?: Json;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface UserUpsertWithWhereUniqueWithoutTenantsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTenantsDataInput;
  create: UserCreateWithoutTenantsInput;
}

export interface SettingsUpdateOneWithoutTenantInput {
  create?: SettingsCreateWithoutTenantInput;
  update?: SettingsUpdateWithoutTenantDataInput;
  upsert?: SettingsUpsertWithoutTenantInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SettingsWhereUniqueInput;
}

export interface SettingsUpdateWithoutTenantDataInput {
  data?: Json;
}

export interface SettingsUpsertWithoutTenantInput {
  update: SettingsUpdateWithoutTenantDataInput;
  create: SettingsCreateWithoutTenantInput;
}

export interface TenantUpsertNestedInput {
  update: TenantUpdateDataInput;
  create: TenantCreateInput;
}

export interface TenantUpsertWithWhereUniqueWithoutUsersInput {
  where: TenantWhereUniqueInput;
  update: TenantUpdateWithoutUsersDataInput;
  create: TenantCreateWithoutUsersInput;
}

export interface TenantScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isActive?: Boolean;
  isActive_not?: Boolean;
  domain?: String;
  domain_not?: String;
  domain_in?: String[] | String;
  domain_not_in?: String[] | String;
  domain_lt?: String;
  domain_lte?: String;
  domain_gt?: String;
  domain_gte?: String;
  domain_contains?: String;
  domain_not_contains?: String;
  domain_starts_with?: String;
  domain_not_starts_with?: String;
  domain_ends_with?: String;
  domain_not_ends_with?: String;
  apiKey?: String;
  apiKey_not?: String;
  apiKey_in?: String[] | String;
  apiKey_not_in?: String[] | String;
  apiKey_lt?: String;
  apiKey_lte?: String;
  apiKey_gt?: String;
  apiKey_gte?: String;
  apiKey_contains?: String;
  apiKey_not_contains?: String;
  apiKey_starts_with?: String;
  apiKey_not_starts_with?: String;
  apiKey_ends_with?: String;
  apiKey_not_ends_with?: String;
  AND?: TenantScalarWhereInput[] | TenantScalarWhereInput;
  OR?: TenantScalarWhereInput[] | TenantScalarWhereInput;
  NOT?: TenantScalarWhereInput[] | TenantScalarWhereInput;
}

export interface TenantUpdateManyWithWhereNestedInput {
  where: TenantScalarWhereInput;
  data: TenantUpdateManyDataInput;
}

export interface TenantUpdateManyDataInput {
  isActive?: Boolean;
  domain?: String;
  apiKey?: String;
}

export interface UserUpsertWithoutAddressesInput {
  update: UserUpdateWithoutAddressesDataInput;
  create: UserCreateWithoutAddressesInput;
}

export interface AddressUpdateManyMutationInput {
  type?: AddressTypes;
  street?: String;
  suite?: String;
  city?: String;
  provinceState?: String;
  postalcode?: String;
}

export interface CommentCreateInput {
  content?: String;
  post: PostCreateOneWithoutCommentsInput;
  author: UserCreateOneWithoutCommentsInput;
}

export interface CommentUpdateInput {
  content?: String;
  post?: PostUpdateOneRequiredWithoutCommentsInput;
  author?: UserUpdateOneRequiredWithoutCommentsInput;
}

export interface CommentUpdateManyMutationInput {
  content?: String;
}

export interface CompanyUpdateInput {
  name?: String;
  address?: AddressUpdateOneRequiredInput;
  contactNumber?: TelephoneNumberUpdateOneRequiredInput;
  contactEmail?: String;
  domain?: String;
  contactPerson?: String;
}

export interface CompanyUpdateManyMutationInput {
  name?: String;
  contactEmail?: String;
  domain?: String;
  contactPerson?: String;
}

export interface CoordinateUpdateInput {
  latitude?: String;
  longitude?: String;
}

export interface CoordinateUpdateManyMutationInput {
  latitude?: String;
  longitude?: String;
}

export interface ImageCreateInput {
  url: String;
  name?: String;
  description?: String;
  alt?: String;
  owner: UserCreateOneWithoutImagesInput;
}

export interface UserCreateOneWithoutImagesInput {
  create?: UserCreateWithoutImagesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutImagesInput {
  isActive?: Boolean;
  email: String;
  emailVerified?: Boolean;
  password: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressCreateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberCreateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantCreateManyWithoutUsersInput;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface ImageUpdateInput {
  url?: String;
  name?: String;
  description?: String;
  alt?: String;
  owner?: UserUpdateOneRequiredWithoutImagesInput;
}

export interface UserUpdateOneRequiredWithoutImagesInput {
  create?: UserCreateWithoutImagesInput;
  update?: UserUpdateWithoutImagesDataInput;
  upsert?: UserUpsertWithoutImagesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutImagesDataInput {
  isActive?: Boolean;
  email?: String;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressUpdateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberUpdateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantUpdateManyWithoutUsersInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface UserUpsertWithoutImagesInput {
  update: UserUpdateWithoutImagesDataInput;
  create: UserCreateWithoutImagesInput;
}

export interface ImageUpdateManyMutationInput {
  url?: String;
  name?: String;
  description?: String;
  alt?: String;
}

export interface PermissionCreateInput {
  permissionName: Permissions;
  roles?: RoleCreateManyWithoutPermissionsInput;
}

export interface RoleCreateManyWithoutPermissionsInput {
  create?:
    | RoleCreateWithoutPermissionsInput[]
    | RoleCreateWithoutPermissionsInput;
  connect?: RoleWhereUniqueInput[] | RoleWhereUniqueInput;
}

export interface RoleCreateWithoutPermissionsInput {
  roleName: Roles;
}

export interface PermissionUpdateInput {
  permissionName?: Permissions;
  roles?: RoleUpdateManyWithoutPermissionsInput;
}

export interface RoleUpdateManyWithoutPermissionsInput {
  create?:
    | RoleCreateWithoutPermissionsInput[]
    | RoleCreateWithoutPermissionsInput;
  delete?: RoleWhereUniqueInput[] | RoleWhereUniqueInput;
  connect?: RoleWhereUniqueInput[] | RoleWhereUniqueInput;
  disconnect?: RoleWhereUniqueInput[] | RoleWhereUniqueInput;
  update?:
    | RoleUpdateWithWhereUniqueWithoutPermissionsInput[]
    | RoleUpdateWithWhereUniqueWithoutPermissionsInput;
  upsert?:
    | RoleUpsertWithWhereUniqueWithoutPermissionsInput[]
    | RoleUpsertWithWhereUniqueWithoutPermissionsInput;
  deleteMany?: RoleScalarWhereInput[] | RoleScalarWhereInput;
  updateMany?:
    | RoleUpdateManyWithWhereNestedInput[]
    | RoleUpdateManyWithWhereNestedInput;
}

export interface RoleUpdateWithWhereUniqueWithoutPermissionsInput {
  where: RoleWhereUniqueInput;
  data: RoleUpdateWithoutPermissionsDataInput;
}

export interface RoleUpdateWithoutPermissionsDataInput {
  roleName?: Roles;
}

export interface RoleUpsertWithWhereUniqueWithoutPermissionsInput {
  where: RoleWhereUniqueInput;
  update: RoleUpdateWithoutPermissionsDataInput;
  create: RoleCreateWithoutPermissionsInput;
}

export interface RoleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  roleName?: Roles;
  roleName_not?: Roles;
  roleName_in?: Roles[] | Roles;
  roleName_not_in?: Roles[] | Roles;
  AND?: RoleScalarWhereInput[] | RoleScalarWhereInput;
  OR?: RoleScalarWhereInput[] | RoleScalarWhereInput;
  NOT?: RoleScalarWhereInput[] | RoleScalarWhereInput;
}

export interface RoleUpdateManyWithWhereNestedInput {
  where: RoleScalarWhereInput;
  data: RoleUpdateManyDataInput;
}

export interface RoleUpdateManyDataInput {
  roleName?: Roles;
}

export interface PermissionUpdateManyMutationInput {
  permissionName?: Permissions;
}

export interface PostCreateInput {
  title: String;
  content?: String;
  published?: Boolean;
  author: UserCreateOneWithoutPostsInput;
  likedBy?: UserCreateManyWithoutLikedPostsInput;
  comments?: CommentCreateManyWithoutPostInput;
}

export interface PostUpdateInput {
  title?: String;
  content?: String;
  published?: Boolean;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  likedBy?: UserUpdateManyWithoutLikedPostsInput;
  comments?: CommentUpdateManyWithoutPostInput;
}

export interface PostUpdateManyMutationInput {
  title?: String;
  content?: String;
  published?: Boolean;
}

export interface ProductCreateInput {
  name: String;
}

export interface ProductUpdateInput {
  name?: String;
}

export interface ProductUpdateManyMutationInput {
  name?: String;
}

export interface RoleCreateInput {
  roleName: Roles;
  permissions?: PermissionCreateManyWithoutRolesInput;
}

export interface PermissionCreateManyWithoutRolesInput {
  create?:
    | PermissionCreateWithoutRolesInput[]
    | PermissionCreateWithoutRolesInput;
  connect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
}

export interface PermissionCreateWithoutRolesInput {
  permissionName: Permissions;
}

export interface RoleUpdateInput {
  roleName?: Roles;
  permissions?: PermissionUpdateManyWithoutRolesInput;
}

export interface PermissionUpdateManyWithoutRolesInput {
  create?:
    | PermissionCreateWithoutRolesInput[]
    | PermissionCreateWithoutRolesInput;
  delete?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  connect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  disconnect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  update?:
    | PermissionUpdateWithWhereUniqueWithoutRolesInput[]
    | PermissionUpdateWithWhereUniqueWithoutRolesInput;
  upsert?:
    | PermissionUpsertWithWhereUniqueWithoutRolesInput[]
    | PermissionUpsertWithWhereUniqueWithoutRolesInput;
  deleteMany?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
  updateMany?:
    | PermissionUpdateManyWithWhereNestedInput[]
    | PermissionUpdateManyWithWhereNestedInput;
}

export interface PermissionUpdateWithWhereUniqueWithoutRolesInput {
  where: PermissionWhereUniqueInput;
  data: PermissionUpdateWithoutRolesDataInput;
}

export interface PermissionUpdateWithoutRolesDataInput {
  permissionName?: Permissions;
}

export interface PermissionUpsertWithWhereUniqueWithoutRolesInput {
  where: PermissionWhereUniqueInput;
  update: PermissionUpdateWithoutRolesDataInput;
  create: PermissionCreateWithoutRolesInput;
}

export interface PermissionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  permissionName?: Permissions;
  permissionName_not?: Permissions;
  permissionName_in?: Permissions[] | Permissions;
  permissionName_not_in?: Permissions[] | Permissions;
  AND?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
  OR?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
  NOT?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
}

export interface PermissionUpdateManyWithWhereNestedInput {
  where: PermissionScalarWhereInput;
  data: PermissionUpdateManyDataInput;
}

export interface PermissionUpdateManyDataInput {
  permissionName?: Permissions;
}

export interface RoleUpdateManyMutationInput {
  roleName?: Roles;
}

export interface SettingsCreateInput {
  tenant?: TenantCreateOneWithoutSettingsInput;
  data?: Json;
}

export interface TenantCreateOneWithoutSettingsInput {
  create?: TenantCreateWithoutSettingsInput;
  connect?: TenantWhereUniqueInput;
}

export interface TenantCreateWithoutSettingsInput {
  isActive?: Boolean;
  domain: String;
  apiKey?: String;
  users?: UserCreateManyWithoutTenantsInput;
  company: CompanyCreateOneInput;
  parent?: TenantCreateOneInput;
}

export interface SettingsUpdateInput {
  tenant?: TenantUpdateOneWithoutSettingsInput;
  data?: Json;
}

export interface TenantUpdateOneWithoutSettingsInput {
  create?: TenantCreateWithoutSettingsInput;
  update?: TenantUpdateWithoutSettingsDataInput;
  upsert?: TenantUpsertWithoutSettingsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: TenantWhereUniqueInput;
}

export interface TenantUpdateWithoutSettingsDataInput {
  isActive?: Boolean;
  domain?: String;
  apiKey?: String;
  users?: UserUpdateManyWithoutTenantsInput;
  company?: CompanyUpdateOneRequiredInput;
  parent?: TenantUpdateOneInput;
}

export interface TenantUpsertWithoutSettingsInput {
  update: TenantUpdateWithoutSettingsDataInput;
  create: TenantCreateWithoutSettingsInput;
}

export interface SettingsUpdateManyMutationInput {
  data?: Json;
}

export interface TelephoneNumberUpdateInput {
  type?: String;
  telephone?: String;
  owner?: UserUpdateOneRequiredWithoutTelephoneNumbersInput;
}

export interface TelephoneNumberUpdateManyMutationInput {
  type?: String;
  telephone?: String;
}

export interface TenantUpdateInput {
  isActive?: Boolean;
  domain?: String;
  apiKey?: String;
  users?: UserUpdateManyWithoutTenantsInput;
  company?: CompanyUpdateOneRequiredInput;
  parent?: TenantUpdateOneInput;
  settings?: SettingsUpdateOneWithoutTenantInput;
}

export interface TenantUpdateManyMutationInput {
  isActive?: Boolean;
  domain?: String;
  apiKey?: String;
}

export interface TenantUserRoleCreateInput {
  tenant: TenantCreateOneInput;
  user: UserCreateOneInput;
  role?: TenantUserRoleCreateroleInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  isActive?: Boolean;
  email: String;
  emailVerified?: Boolean;
  password: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressCreateManyWithoutOwnerInput;
  images?: ImageCreateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberCreateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantCreateManyWithoutUsersInput;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface TenantUserRoleCreateroleInput {
  set?: Roles[] | Roles;
}

export interface TenantUserRoleUpdateManyMutationInput {
  role?: TenantUserRoleUpdateroleInput;
}

export interface TenantUserRoleUpdateroleInput {
  set?: Roles[] | Roles;
}

export interface TimeZoneUpdateInput {
  offset?: String;
  description?: String;
}

export interface TimeZoneUpdateManyMutationInput {
  offset?: String;
  description?: String;
}

export interface UserUpdateInput {
  isActive?: Boolean;
  email?: String;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  addresses?: AddressUpdateManyWithoutOwnerInput;
  images?: ImageUpdateManyWithoutOwnerInput;
  dob?: DateTimeInput;
  gender?: Genders;
  telephoneNumbers?: TelephoneNumberUpdateManyWithoutOwnerInput;
  userData?: Json;
  tenants?: TenantUpdateManyWithoutUsersInput;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface UserUpdateManyMutationInput {
  isActive?: Boolean;
  email?: String;
  emailVerified?: Boolean;
  password?: String;
  firstName?: String;
  lastName?: String;
  dob?: DateTimeInput;
  gender?: Genders;
  userData?: Json;
  lastLoginAt?: DateTimeInput;
  token?: String;
}

export interface AddressSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AddressWhereInput;
  AND?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  OR?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
  NOT?: AddressSubscriptionWhereInput[] | AddressSubscriptionWhereInput;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentWhereInput;
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompanyWhereInput;
  AND?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  OR?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  NOT?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
}

export interface CoordinateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CoordinateWhereInput;
  AND?: CoordinateSubscriptionWhereInput[] | CoordinateSubscriptionWhereInput;
  OR?: CoordinateSubscriptionWhereInput[] | CoordinateSubscriptionWhereInput;
  NOT?: CoordinateSubscriptionWhereInput[] | CoordinateSubscriptionWhereInput;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ImageWhereInput;
  AND?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  OR?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  NOT?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
}

export interface PermissionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PermissionWhereInput;
  AND?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
  OR?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
  NOT?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostWhereInput;
  AND?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  OR?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  NOT?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface RoleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: RoleWhereInput;
  AND?: RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput;
  OR?: RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput;
  NOT?: RoleSubscriptionWhereInput[] | RoleSubscriptionWhereInput;
}

export interface SettingsSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SettingsWhereInput;
  AND?: SettingsSubscriptionWhereInput[] | SettingsSubscriptionWhereInput;
  OR?: SettingsSubscriptionWhereInput[] | SettingsSubscriptionWhereInput;
  NOT?: SettingsSubscriptionWhereInput[] | SettingsSubscriptionWhereInput;
}

export interface TelephoneNumberSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TelephoneNumberWhereInput;
  AND?:
    | TelephoneNumberSubscriptionWhereInput[]
    | TelephoneNumberSubscriptionWhereInput;
  OR?:
    | TelephoneNumberSubscriptionWhereInput[]
    | TelephoneNumberSubscriptionWhereInput;
  NOT?:
    | TelephoneNumberSubscriptionWhereInput[]
    | TelephoneNumberSubscriptionWhereInput;
}

export interface TenantSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TenantWhereInput;
  AND?: TenantSubscriptionWhereInput[] | TenantSubscriptionWhereInput;
  OR?: TenantSubscriptionWhereInput[] | TenantSubscriptionWhereInput;
  NOT?: TenantSubscriptionWhereInput[] | TenantSubscriptionWhereInput;
}

export interface TenantUserRoleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TenantUserRoleWhereInput;
  AND?:
    | TenantUserRoleSubscriptionWhereInput[]
    | TenantUserRoleSubscriptionWhereInput;
  OR?:
    | TenantUserRoleSubscriptionWhereInput[]
    | TenantUserRoleSubscriptionWhereInput;
  NOT?:
    | TenantUserRoleSubscriptionWhereInput[]
    | TenantUserRoleSubscriptionWhereInput;
}

export interface TimeZoneSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TimeZoneWhereInput;
  AND?: TimeZoneSubscriptionWhereInput[] | TimeZoneSubscriptionWhereInput;
  OR?: TimeZoneSubscriptionWhereInput[] | TimeZoneSubscriptionWhereInput;
  NOT?: TimeZoneSubscriptionWhereInput[] | TimeZoneSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Address {
  id: ID_Output;
  type: AddressTypes;
  street: String;
  suite?: String;
  city: String;
  provinceState: String;
  postalcode: String;
}

export interface AddressPromise extends Promise<Address>, Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<AddressTypes>;
  street: () => Promise<String>;
  suite: () => Promise<String>;
  city: () => Promise<String>;
  provinceState: () => Promise<String>;
  postalcode: () => Promise<String>;
  coordinate: <T = CoordinatePromise>() => T;
  timezone: <T = TimeZonePromise>() => T;
  owner: <T = UserPromise>() => T;
}

export interface AddressSubscription
  extends Promise<AsyncIterator<Address>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<AddressTypes>>;
  street: () => Promise<AsyncIterator<String>>;
  suite: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  provinceState: () => Promise<AsyncIterator<String>>;
  postalcode: () => Promise<AsyncIterator<String>>;
  coordinate: <T = CoordinateSubscription>() => T;
  timezone: <T = TimeZoneSubscription>() => T;
  owner: <T = UserSubscription>() => T;
}

export interface Coordinate {
  id: ID_Output;
  latitude: String;
  longitude: String;
}

export interface CoordinatePromise extends Promise<Coordinate>, Fragmentable {
  id: () => Promise<ID_Output>;
  latitude: () => Promise<String>;
  longitude: () => Promise<String>;
}

export interface CoordinateSubscription
  extends Promise<AsyncIterator<Coordinate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  latitude: () => Promise<AsyncIterator<String>>;
  longitude: () => Promise<AsyncIterator<String>>;
}

export interface TimeZone {
  id: ID_Output;
  offset?: String;
  description?: String;
}

export interface TimeZonePromise extends Promise<TimeZone>, Fragmentable {
  id: () => Promise<ID_Output>;
  offset: () => Promise<String>;
  description: () => Promise<String>;
}

export interface TimeZoneSubscription
  extends Promise<AsyncIterator<TimeZone>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  offset: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  isActive: Boolean;
  email: String;
  emailVerified: Boolean;
  password: String;
  firstName?: String;
  lastName?: String;
  dob?: DateTimeOutput;
  gender?: Genders;
  userData?: Json;
  createdAt: DateTimeOutput;
  lastLoginAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  token?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  isActive: () => Promise<Boolean>;
  email: () => Promise<String>;
  emailVerified: () => Promise<Boolean>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  addresses: <T = FragmentableArray<Address>>(
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  images: <T = FragmentableArray<Image>>(
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  dob: () => Promise<DateTimeOutput>;
  gender: () => Promise<Genders>;
  telephoneNumbers: <T = FragmentableArray<TelephoneNumber>>(
    args?: {
      where?: TelephoneNumberWhereInput;
      orderBy?: TelephoneNumberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  userData: () => Promise<Json>;
  tenants: <T = FragmentableArray<Tenant>>(
    args?: {
      where?: TenantWhereInput;
      orderBy?: TenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  posts: <T = FragmentableArray<Post>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likedPosts: <T = FragmentableArray<Post>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  lastLoginAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  token: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  email: () => Promise<AsyncIterator<String>>;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  addresses: <T = Promise<AsyncIterator<AddressSubscription>>>(
    args?: {
      where?: AddressWhereInput;
      orderBy?: AddressOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>(
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  dob: () => Promise<AsyncIterator<DateTimeOutput>>;
  gender: () => Promise<AsyncIterator<Genders>>;
  telephoneNumbers: <T = Promise<AsyncIterator<TelephoneNumberSubscription>>>(
    args?: {
      where?: TelephoneNumberWhereInput;
      orderBy?: TelephoneNumberOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  userData: () => Promise<AsyncIterator<Json>>;
  tenants: <T = Promise<AsyncIterator<TenantSubscription>>>(
    args?: {
      where?: TenantWhereInput;
      orderBy?: TenantOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likedPosts: <T = Promise<AsyncIterator<PostSubscription>>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastLoginAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  token: () => Promise<AsyncIterator<String>>;
}

export interface Image {
  id: ID_Output;
  url: String;
  name?: String;
  description?: String;
  alt?: String;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  alt: () => Promise<String>;
  owner: <T = UserPromise>() => T;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  alt: () => Promise<AsyncIterator<String>>;
  owner: <T = UserSubscription>() => T;
}

export interface TelephoneNumber {
  id: ID_Output;
  type: String;
  telephone: String;
}

export interface TelephoneNumberPromise
  extends Promise<TelephoneNumber>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  telephone: () => Promise<String>;
  owner: <T = UserPromise>() => T;
}

export interface TelephoneNumberSubscription
  extends Promise<AsyncIterator<TelephoneNumber>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  telephone: () => Promise<AsyncIterator<String>>;
  owner: <T = UserSubscription>() => T;
}

export interface Tenant {
  id: ID_Output;
  isActive: Boolean;
  domain: String;
  apiKey?: String;
}

export interface TenantPromise extends Promise<Tenant>, Fragmentable {
  id: () => Promise<ID_Output>;
  isActive: () => Promise<Boolean>;
  domain: () => Promise<String>;
  apiKey: () => Promise<String>;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  company: <T = CompanyPromise>() => T;
  parent: <T = TenantPromise>() => T;
  settings: <T = SettingsPromise>() => T;
}

export interface TenantSubscription
  extends Promise<AsyncIterator<Tenant>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  domain: () => Promise<AsyncIterator<String>>;
  apiKey: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  company: <T = CompanySubscription>() => T;
  parent: <T = TenantSubscription>() => T;
  settings: <T = SettingsSubscription>() => T;
}

export interface Company {
  id: ID_Output;
  name: String;
  contactEmail: String;
  domain: String;
  contactPerson?: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  address: <T = AddressPromise>() => T;
  contactNumber: <T = TelephoneNumberPromise>() => T;
  contactEmail: () => Promise<String>;
  domain: () => Promise<String>;
  contactPerson: () => Promise<String>;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  address: <T = AddressSubscription>() => T;
  contactNumber: <T = TelephoneNumberSubscription>() => T;
  contactEmail: () => Promise<AsyncIterator<String>>;
  domain: () => Promise<AsyncIterator<String>>;
  contactPerson: () => Promise<AsyncIterator<String>>;
}

export interface Settings {
  id: ID_Output;
  data?: Json;
}

export interface SettingsPromise extends Promise<Settings>, Fragmentable {
  id: () => Promise<ID_Output>;
  tenant: <T = TenantPromise>() => T;
  data: () => Promise<Json>;
}

export interface SettingsSubscription
  extends Promise<AsyncIterator<Settings>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  tenant: <T = TenantSubscription>() => T;
  data: () => Promise<AsyncIterator<Json>>;
}

export interface Post {
  id: ID_Output;
  title: String;
  content?: String;
  published: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  published: () => Promise<Boolean>;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  author: <T = UserSubscription>() => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Comment {
  id: ID_Output;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  post: <T = PostPromise>() => T;
  author: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  post: <T = PostSubscription>() => T;
  author: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AddressConnection {
  pageInfo: PageInfo;
  edges: AddressEdge[];
}

export interface AddressConnectionPromise
  extends Promise<AddressConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AddressEdge>>() => T;
  aggregate: <T = AggregateAddressPromise>() => T;
}

export interface AddressConnectionSubscription
  extends Promise<AsyncIterator<AddressConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AddressEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAddressSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AddressEdge {
  node: Address;
  cursor: String;
}

export interface AddressEdgePromise extends Promise<AddressEdge>, Fragmentable {
  node: <T = AddressPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AddressEdgeSubscription
  extends Promise<AsyncIterator<AddressEdge>>,
    Fragmentable {
  node: <T = AddressSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAddress {
  count: Int;
}

export interface AggregateAddressPromise
  extends Promise<AggregateAddress>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAddressSubscription
  extends Promise<AsyncIterator<AggregateAddress>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CoordinateConnection {
  pageInfo: PageInfo;
  edges: CoordinateEdge[];
}

export interface CoordinateConnectionPromise
  extends Promise<CoordinateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CoordinateEdge>>() => T;
  aggregate: <T = AggregateCoordinatePromise>() => T;
}

export interface CoordinateConnectionSubscription
  extends Promise<AsyncIterator<CoordinateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CoordinateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCoordinateSubscription>() => T;
}

export interface CoordinateEdge {
  node: Coordinate;
  cursor: String;
}

export interface CoordinateEdgePromise
  extends Promise<CoordinateEdge>,
    Fragmentable {
  node: <T = CoordinatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CoordinateEdgeSubscription
  extends Promise<AsyncIterator<CoordinateEdge>>,
    Fragmentable {
  node: <T = CoordinateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCoordinate {
  count: Int;
}

export interface AggregateCoordinatePromise
  extends Promise<AggregateCoordinate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCoordinateSubscription
  extends Promise<AsyncIterator<AggregateCoordinate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Permission {
  id: ID_Output;
  permissionName: Permissions;
}

export interface PermissionPromise extends Promise<Permission>, Fragmentable {
  id: () => Promise<ID_Output>;
  permissionName: () => Promise<Permissions>;
  roles: <T = FragmentableArray<Role>>(
    args?: {
      where?: RoleWhereInput;
      orderBy?: RoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PermissionSubscription
  extends Promise<AsyncIterator<Permission>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  permissionName: () => Promise<AsyncIterator<Permissions>>;
  roles: <T = Promise<AsyncIterator<RoleSubscription>>>(
    args?: {
      where?: RoleWhereInput;
      orderBy?: RoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Role {
  id: ID_Output;
  roleName: Roles;
}

export interface RolePromise extends Promise<Role>, Fragmentable {
  id: () => Promise<ID_Output>;
  roleName: () => Promise<Roles>;
  permissions: <T = FragmentableArray<Permission>>(
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface RoleSubscription
  extends Promise<AsyncIterator<Role>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  roleName: () => Promise<AsyncIterator<Roles>>;
  permissions: <T = Promise<AsyncIterator<PermissionSubscription>>>(
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PermissionConnection {
  pageInfo: PageInfo;
  edges: PermissionEdge[];
}

export interface PermissionConnectionPromise
  extends Promise<PermissionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PermissionEdge>>() => T;
  aggregate: <T = AggregatePermissionPromise>() => T;
}

export interface PermissionConnectionSubscription
  extends Promise<AsyncIterator<PermissionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PermissionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePermissionSubscription>() => T;
}

export interface PermissionEdge {
  node: Permission;
  cursor: String;
}

export interface PermissionEdgePromise
  extends Promise<PermissionEdge>,
    Fragmentable {
  node: <T = PermissionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PermissionEdgeSubscription
  extends Promise<AsyncIterator<PermissionEdge>>,
    Fragmentable {
  node: <T = PermissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePermission {
  count: Int;
}

export interface AggregatePermissionPromise
  extends Promise<AggregatePermission>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePermissionSubscription
  extends Promise<AsyncIterator<AggregatePermission>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Product {
  id: ID_Output;
  name: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoleConnection {
  pageInfo: PageInfo;
  edges: RoleEdge[];
}

export interface RoleConnectionPromise
  extends Promise<RoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoleEdge>>() => T;
  aggregate: <T = AggregateRolePromise>() => T;
}

export interface RoleConnectionSubscription
  extends Promise<AsyncIterator<RoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoleSubscription>() => T;
}

export interface RoleEdge {
  node: Role;
  cursor: String;
}

export interface RoleEdgePromise extends Promise<RoleEdge>, Fragmentable {
  node: <T = RolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoleEdgeSubscription
  extends Promise<AsyncIterator<RoleEdge>>,
    Fragmentable {
  node: <T = RoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRole {
  count: Int;
}

export interface AggregateRolePromise
  extends Promise<AggregateRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoleSubscription
  extends Promise<AsyncIterator<AggregateRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SettingsConnection {
  pageInfo: PageInfo;
  edges: SettingsEdge[];
}

export interface SettingsConnectionPromise
  extends Promise<SettingsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SettingsEdge>>() => T;
  aggregate: <T = AggregateSettingsPromise>() => T;
}

export interface SettingsConnectionSubscription
  extends Promise<AsyncIterator<SettingsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SettingsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSettingsSubscription>() => T;
}

export interface SettingsEdge {
  node: Settings;
  cursor: String;
}

export interface SettingsEdgePromise
  extends Promise<SettingsEdge>,
    Fragmentable {
  node: <T = SettingsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SettingsEdgeSubscription
  extends Promise<AsyncIterator<SettingsEdge>>,
    Fragmentable {
  node: <T = SettingsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSettings {
  count: Int;
}

export interface AggregateSettingsPromise
  extends Promise<AggregateSettings>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSettingsSubscription
  extends Promise<AsyncIterator<AggregateSettings>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TelephoneNumberConnection {
  pageInfo: PageInfo;
  edges: TelephoneNumberEdge[];
}

export interface TelephoneNumberConnectionPromise
  extends Promise<TelephoneNumberConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TelephoneNumberEdge>>() => T;
  aggregate: <T = AggregateTelephoneNumberPromise>() => T;
}

export interface TelephoneNumberConnectionSubscription
  extends Promise<AsyncIterator<TelephoneNumberConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TelephoneNumberEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTelephoneNumberSubscription>() => T;
}

export interface TelephoneNumberEdge {
  node: TelephoneNumber;
  cursor: String;
}

export interface TelephoneNumberEdgePromise
  extends Promise<TelephoneNumberEdge>,
    Fragmentable {
  node: <T = TelephoneNumberPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TelephoneNumberEdgeSubscription
  extends Promise<AsyncIterator<TelephoneNumberEdge>>,
    Fragmentable {
  node: <T = TelephoneNumberSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTelephoneNumber {
  count: Int;
}

export interface AggregateTelephoneNumberPromise
  extends Promise<AggregateTelephoneNumber>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTelephoneNumberSubscription
  extends Promise<AsyncIterator<AggregateTelephoneNumber>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TenantConnection {
  pageInfo: PageInfo;
  edges: TenantEdge[];
}

export interface TenantConnectionPromise
  extends Promise<TenantConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TenantEdge>>() => T;
  aggregate: <T = AggregateTenantPromise>() => T;
}

export interface TenantConnectionSubscription
  extends Promise<AsyncIterator<TenantConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TenantEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTenantSubscription>() => T;
}

export interface TenantEdge {
  node: Tenant;
  cursor: String;
}

export interface TenantEdgePromise extends Promise<TenantEdge>, Fragmentable {
  node: <T = TenantPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TenantEdgeSubscription
  extends Promise<AsyncIterator<TenantEdge>>,
    Fragmentable {
  node: <T = TenantSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTenant {
  count: Int;
}

export interface AggregateTenantPromise
  extends Promise<AggregateTenant>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTenantSubscription
  extends Promise<AsyncIterator<AggregateTenant>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TenantUserRole {
  role: Roles[];
}

export interface TenantUserRolePromise
  extends Promise<TenantUserRole>,
    Fragmentable {
  tenant: <T = TenantPromise>() => T;
  user: <T = UserPromise>() => T;
  role: () => Promise<Roles[]>;
}

export interface TenantUserRoleSubscription
  extends Promise<AsyncIterator<TenantUserRole>>,
    Fragmentable {
  tenant: <T = TenantSubscription>() => T;
  user: <T = UserSubscription>() => T;
  role: () => Promise<AsyncIterator<Roles[]>>;
}

export interface TenantUserRoleConnection {
  pageInfo: PageInfo;
  edges: TenantUserRoleEdge[];
}

export interface TenantUserRoleConnectionPromise
  extends Promise<TenantUserRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TenantUserRoleEdge>>() => T;
  aggregate: <T = AggregateTenantUserRolePromise>() => T;
}

export interface TenantUserRoleConnectionSubscription
  extends Promise<AsyncIterator<TenantUserRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TenantUserRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTenantUserRoleSubscription>() => T;
}

export interface TenantUserRoleEdge {
  node: TenantUserRole;
  cursor: String;
}

export interface TenantUserRoleEdgePromise
  extends Promise<TenantUserRoleEdge>,
    Fragmentable {
  node: <T = TenantUserRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TenantUserRoleEdgeSubscription
  extends Promise<AsyncIterator<TenantUserRoleEdge>>,
    Fragmentable {
  node: <T = TenantUserRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTenantUserRole {
  count: Int;
}

export interface AggregateTenantUserRolePromise
  extends Promise<AggregateTenantUserRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTenantUserRoleSubscription
  extends Promise<AsyncIterator<AggregateTenantUserRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TimeZoneConnection {
  pageInfo: PageInfo;
  edges: TimeZoneEdge[];
}

export interface TimeZoneConnectionPromise
  extends Promise<TimeZoneConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TimeZoneEdge>>() => T;
  aggregate: <T = AggregateTimeZonePromise>() => T;
}

export interface TimeZoneConnectionSubscription
  extends Promise<AsyncIterator<TimeZoneConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TimeZoneEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTimeZoneSubscription>() => T;
}

export interface TimeZoneEdge {
  node: TimeZone;
  cursor: String;
}

export interface TimeZoneEdgePromise
  extends Promise<TimeZoneEdge>,
    Fragmentable {
  node: <T = TimeZonePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TimeZoneEdgeSubscription
  extends Promise<AsyncIterator<TimeZoneEdge>>,
    Fragmentable {
  node: <T = TimeZoneSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTimeZone {
  count: Int;
}

export interface AggregateTimeZonePromise
  extends Promise<AggregateTimeZone>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTimeZoneSubscription
  extends Promise<AsyncIterator<AggregateTimeZone>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AddressSubscriptionPayload {
  mutation: MutationType;
  node: Address;
  updatedFields: String[];
  previousValues: AddressPreviousValues;
}

export interface AddressSubscriptionPayloadPromise
  extends Promise<AddressSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AddressPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AddressPreviousValuesPromise>() => T;
}

export interface AddressSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AddressSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AddressSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AddressPreviousValuesSubscription>() => T;
}

export interface AddressPreviousValues {
  id: ID_Output;
  type: AddressTypes;
  street: String;
  suite?: String;
  city: String;
  provinceState: String;
  postalcode: String;
}

export interface AddressPreviousValuesPromise
  extends Promise<AddressPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<AddressTypes>;
  street: () => Promise<String>;
  suite: () => Promise<String>;
  city: () => Promise<String>;
  provinceState: () => Promise<String>;
  postalcode: () => Promise<String>;
}

export interface AddressPreviousValuesSubscription
  extends Promise<AsyncIterator<AddressPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<AddressTypes>>;
  street: () => Promise<AsyncIterator<String>>;
  suite: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  provinceState: () => Promise<AsyncIterator<String>>;
  postalcode: () => Promise<AsyncIterator<String>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  content?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  content: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  content: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  name: String;
  contactEmail: String;
  domain: String;
  contactPerson?: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  contactEmail: () => Promise<String>;
  domain: () => Promise<String>;
  contactPerson: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  contactEmail: () => Promise<AsyncIterator<String>>;
  domain: () => Promise<AsyncIterator<String>>;
  contactPerson: () => Promise<AsyncIterator<String>>;
}

export interface CoordinateSubscriptionPayload {
  mutation: MutationType;
  node: Coordinate;
  updatedFields: String[];
  previousValues: CoordinatePreviousValues;
}

export interface CoordinateSubscriptionPayloadPromise
  extends Promise<CoordinateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CoordinatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CoordinatePreviousValuesPromise>() => T;
}

export interface CoordinateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CoordinateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CoordinateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CoordinatePreviousValuesSubscription>() => T;
}

export interface CoordinatePreviousValues {
  id: ID_Output;
  latitude: String;
  longitude: String;
}

export interface CoordinatePreviousValuesPromise
  extends Promise<CoordinatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  latitude: () => Promise<String>;
  longitude: () => Promise<String>;
}

export interface CoordinatePreviousValuesSubscription
  extends Promise<AsyncIterator<CoordinatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  latitude: () => Promise<AsyncIterator<String>>;
  longitude: () => Promise<AsyncIterator<String>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface ImagePreviousValues {
  id: ID_Output;
  url: String;
  name?: String;
  description?: String;
  alt?: String;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  url: () => Promise<String>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  alt: () => Promise<String>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  url: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  alt: () => Promise<AsyncIterator<String>>;
}

export interface PermissionSubscriptionPayload {
  mutation: MutationType;
  node: Permission;
  updatedFields: String[];
  previousValues: PermissionPreviousValues;
}

export interface PermissionSubscriptionPayloadPromise
  extends Promise<PermissionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PermissionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PermissionPreviousValuesPromise>() => T;
}

export interface PermissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PermissionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PermissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PermissionPreviousValuesSubscription>() => T;
}

export interface PermissionPreviousValues {
  id: ID_Output;
  permissionName: Permissions;
}

export interface PermissionPreviousValuesPromise
  extends Promise<PermissionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  permissionName: () => Promise<Permissions>;
}

export interface PermissionPreviousValuesSubscription
  extends Promise<AsyncIterator<PermissionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  permissionName: () => Promise<AsyncIterator<Permissions>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface PostPreviousValues {
  id: ID_Output;
  title: String;
  content?: String;
  published: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  content: () => Promise<String>;
  published: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  content: () => Promise<AsyncIterator<String>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface RoleSubscriptionPayload {
  mutation: MutationType;
  node: Role;
  updatedFields: String[];
  previousValues: RolePreviousValues;
}

export interface RoleSubscriptionPayloadPromise
  extends Promise<RoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RolePreviousValuesPromise>() => T;
}

export interface RoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RolePreviousValuesSubscription>() => T;
}

export interface RolePreviousValues {
  id: ID_Output;
  roleName: Roles;
}

export interface RolePreviousValuesPromise
  extends Promise<RolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  roleName: () => Promise<Roles>;
}

export interface RolePreviousValuesSubscription
  extends Promise<AsyncIterator<RolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  roleName: () => Promise<AsyncIterator<Roles>>;
}

export interface SettingsSubscriptionPayload {
  mutation: MutationType;
  node: Settings;
  updatedFields: String[];
  previousValues: SettingsPreviousValues;
}

export interface SettingsSubscriptionPayloadPromise
  extends Promise<SettingsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SettingsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SettingsPreviousValuesPromise>() => T;
}

export interface SettingsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SettingsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SettingsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SettingsPreviousValuesSubscription>() => T;
}

export interface SettingsPreviousValues {
  id: ID_Output;
  data?: Json;
}

export interface SettingsPreviousValuesPromise
  extends Promise<SettingsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  data: () => Promise<Json>;
}

export interface SettingsPreviousValuesSubscription
  extends Promise<AsyncIterator<SettingsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  data: () => Promise<AsyncIterator<Json>>;
}

export interface TelephoneNumberSubscriptionPayload {
  mutation: MutationType;
  node: TelephoneNumber;
  updatedFields: String[];
  previousValues: TelephoneNumberPreviousValues;
}

export interface TelephoneNumberSubscriptionPayloadPromise
  extends Promise<TelephoneNumberSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TelephoneNumberPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TelephoneNumberPreviousValuesPromise>() => T;
}

export interface TelephoneNumberSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TelephoneNumberSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TelephoneNumberSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TelephoneNumberPreviousValuesSubscription>() => T;
}

export interface TelephoneNumberPreviousValues {
  id: ID_Output;
  type: String;
  telephone: String;
}

export interface TelephoneNumberPreviousValuesPromise
  extends Promise<TelephoneNumberPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  type: () => Promise<String>;
  telephone: () => Promise<String>;
}

export interface TelephoneNumberPreviousValuesSubscription
  extends Promise<AsyncIterator<TelephoneNumberPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  type: () => Promise<AsyncIterator<String>>;
  telephone: () => Promise<AsyncIterator<String>>;
}

export interface TenantSubscriptionPayload {
  mutation: MutationType;
  node: Tenant;
  updatedFields: String[];
  previousValues: TenantPreviousValues;
}

export interface TenantSubscriptionPayloadPromise
  extends Promise<TenantSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TenantPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TenantPreviousValuesPromise>() => T;
}

export interface TenantSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TenantSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TenantSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TenantPreviousValuesSubscription>() => T;
}

export interface TenantPreviousValues {
  id: ID_Output;
  isActive: Boolean;
  domain: String;
  apiKey?: String;
}

export interface TenantPreviousValuesPromise
  extends Promise<TenantPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isActive: () => Promise<Boolean>;
  domain: () => Promise<String>;
  apiKey: () => Promise<String>;
}

export interface TenantPreviousValuesSubscription
  extends Promise<AsyncIterator<TenantPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  domain: () => Promise<AsyncIterator<String>>;
  apiKey: () => Promise<AsyncIterator<String>>;
}

export interface TenantUserRoleSubscriptionPayload {
  mutation: MutationType;
  node: TenantUserRole;
  updatedFields: String[];
  previousValues: TenantUserRolePreviousValues;
}

export interface TenantUserRoleSubscriptionPayloadPromise
  extends Promise<TenantUserRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TenantUserRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TenantUserRolePreviousValuesPromise>() => T;
}

export interface TenantUserRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TenantUserRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TenantUserRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TenantUserRolePreviousValuesSubscription>() => T;
}

export interface TenantUserRolePreviousValues {
  role: Roles[];
}

export interface TenantUserRolePreviousValuesPromise
  extends Promise<TenantUserRolePreviousValues>,
    Fragmentable {
  role: () => Promise<Roles[]>;
}

export interface TenantUserRolePreviousValuesSubscription
  extends Promise<AsyncIterator<TenantUserRolePreviousValues>>,
    Fragmentable {
  role: () => Promise<AsyncIterator<Roles[]>>;
}

export interface TimeZoneSubscriptionPayload {
  mutation: MutationType;
  node: TimeZone;
  updatedFields: String[];
  previousValues: TimeZonePreviousValues;
}

export interface TimeZoneSubscriptionPayloadPromise
  extends Promise<TimeZoneSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TimeZonePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TimeZonePreviousValuesPromise>() => T;
}

export interface TimeZoneSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TimeZoneSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TimeZoneSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TimeZonePreviousValuesSubscription>() => T;
}

export interface TimeZonePreviousValues {
  id: ID_Output;
  offset?: String;
  description?: String;
}

export interface TimeZonePreviousValuesPromise
  extends Promise<TimeZonePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  offset: () => Promise<String>;
  description: () => Promise<String>;
}

export interface TimeZonePreviousValuesSubscription
  extends Promise<AsyncIterator<TimeZonePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  offset: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  isActive: Boolean;
  email: String;
  emailVerified: Boolean;
  password: String;
  firstName?: String;
  lastName?: String;
  dob?: DateTimeOutput;
  gender?: Genders;
  userData?: Json;
  createdAt: DateTimeOutput;
  lastLoginAt?: DateTimeOutput;
  updatedAt: DateTimeOutput;
  token?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isActive: () => Promise<Boolean>;
  email: () => Promise<String>;
  emailVerified: () => Promise<Boolean>;
  password: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  dob: () => Promise<DateTimeOutput>;
  gender: () => Promise<Genders>;
  userData: () => Promise<Json>;
  createdAt: () => Promise<DateTimeOutput>;
  lastLoginAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  token: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isActive: () => Promise<AsyncIterator<Boolean>>;
  email: () => Promise<AsyncIterator<String>>;
  emailVerified: () => Promise<AsyncIterator<Boolean>>;
  password: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  dob: () => Promise<AsyncIterator<DateTimeOutput>>;
  gender: () => Promise<AsyncIterator<Genders>>;
  userData: () => Promise<AsyncIterator<Json>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastLoginAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  token: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Json = any;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Address",
    embedded: false
  },
  {
    name: "AddressTypes",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Coordinate",
    embedded: false
  },
  {
    name: "Genders",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "Permissions",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "Roles",
    embedded: false
  },
  {
    name: "Settings",
    embedded: false
  },
  {
    name: "TelephoneNumber",
    embedded: false
  },
  {
    name: "Tenant",
    embedded: false
  },
  {
    name: "TenantUserRole",
    embedded: false
  },
  {
    name: "TimeZone",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
